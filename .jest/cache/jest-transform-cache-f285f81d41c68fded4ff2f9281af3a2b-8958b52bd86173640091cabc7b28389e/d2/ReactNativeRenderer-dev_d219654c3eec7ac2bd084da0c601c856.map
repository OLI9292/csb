{"version":3,"sources":["ReactNativeRenderer-dev.js"],"names":["__DEV__","require","invariant","warning","emptyFunction","UIManager","RCTEventEmitter","TextInputState","deepDiffer","flattenStyle","React","emptyObject","shallowEqual","ExceptionsManager","checkPropTypes","deepFreezeAndThrowOnMutationInDev","invokeGuardedCallback","name","func","context","a","b","c","d","e","f","_hasCaughtError","_caughtError","funcArgs","Array","prototype","slice","call","arguments","apply","error","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","evt","didError","callCallback","removeEventListener","evtType","didSetError","isCrossOriginError","onError","event","colno","lineno","addEventListener","initEvent","Error","invokeGuardedCallback$1","ReactErrorUtils","_rethrowError","_hasRethrowError","invokeGuardedCallbackAndCatchFirstError","hasCaughtError","clearCaughtError","rethrowCaughtError","eventPluginOrder","namesToPlugins","recomputePluginOrdering","pluginName","pluginModule","pluginIndex","indexOf","plugins","extractEvents","publishedEvents","eventTypes","eventName","publishEventForPlugin","dispatchConfig","eventNameDispatchConfigs","hasOwnProperty","phasedRegistrationNames","phaseName","phasedRegistrationName","publishRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","lowerCasedName","toLowerCase","injectEventPluginOrder","injectedEventPluginOrder","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","injection$1","injectComponentTree","Injected","isEndish","topLevelType","isMoveish","isStartish","validateEventDispatches","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","length","instancesIsArr","instancesLen","executeDispatch","simulated","listener","inst","type","currentTarget","undefined","executeDispatchesInOrder","i","isPropagationStopped","executeDispatchesInOrderStopAtTrueImpl","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","res","hasDispatches","accumulateInto","current","next","push","concat","forEachAccumulated","arr","cb","scope","forEach","eventQueue","executeDispatchesAndRelease","isPersistent","constructor","release","executeDispatchesAndReleaseSimulated","executeDispatchesAndReleaseTopLevel","isInteractive","tag","shouldPreventMouseEvent","props","disabled","injection","getListener","stateNode","targetInst","nativeEvent","nativeEventTarget","events","possiblePlugin","extractedEvents","runEventsInBatch","processingEventQueue","runExtractedEventsInBatch","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostPortal","HostComponent","HostText","CallComponent","CallHandlerPhase","ReturnComponent","Fragment","Mode","ContextConsumer","ContextProvider","ForwardRef","getParent","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","listenerAtPhase","propagationPhase","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","didWarnForAddedNewProperty","EVENT_POOL_SIZE","shouldBeReleasedProperties","EventInterface","target","thatReturnsNull","eventPhase","bubbles","cancelable","timeStamp","Date","now","defaultPrevented","isTrusted","SyntheticEvent","preventDefault","stopPropagation","Interface","propName","normalize","returnValue","isDefaultPrevented","thatReturnsTrue","thatReturnsFalse","cancelBubble","persist","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","extend","Super","E","Class","addEventPoolingTo","isProxySupported","Proxy","isSealed","construct","args","create","that","set","prop","value","getVal","isFunction","configurable","get","val","action","warn","result","warningCondition","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","SyntheticEvent$1","ResponderSyntheticEvent","touchHistory","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","console","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","previousActiveTouches","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","startShouldSetResponder","bubbled","captured","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","_getResponder","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","GlobalInteractionHandler","injectGlobalResponderHandler","injectGlobalInteractionHandler","customBubblingEventTypes","customDirectEventTypes","ReactNativeBridgeEventPlugin","bubbleDispatchConfig","directDispatchConfig","processEventTypes","viewConfig","bubblingEventTypes","directEventTypes","_topLevelType","_topLevelType2","instanceCache","instanceProps","precacheFiberNode","hostInst","uncacheFiberNode","getInstanceFromTag","getTagFromInstance","_nativeTag","canonical","getFiberCurrentPropsFromNode$1","updateFiberProps","ReactNativeComponentTree","freeze","getClosestInstanceFromNode","ReactNativeEventPluginOrder","ReactNativeGlobalResponderHandler","from","to","blockNativeResponder","setJSResponder","clearJSResponder","fiberHostComponent","restoreTarget","restoreQueue","restoreStateOfTarget","internalInstance","restoreControlledState","needsStateRestore","restoreStateIfNeeded","queuedTargets","_batchedUpdates","bookkeeping","_interactiveUpdates","_flushInteractiveUpdates","isBatching","batchedUpdates","controlledComponentsHavePendingUpdates","injection$2","injectRenderer","renderer","interactiveUpdates","flushInteractiveUpdates","INITIAL_TAG_COUNT","ReactNativeTagHandles","tagsStartAt","tagCount","allocateTag","reactTagIsNativeTopRootID","assertRootTag","reactTag","EMPTY_NATIVE_EVENT","touchSubsequence","indices","removeTouchesAtIndices","rippedOut","temp","index","fillAt","j","cur","_receiveRootNodeIDEvent","rootNodeID","nativeEventParam","receiveEvent","receiveTouches","eventTopLevelType","changedIndices","jj","ReactNativeEventEmitter","registrationNames","register","hasSymbol","Symbol","REACT_ELEMENT_TYPE","REACT_CALL_TYPE","REACT_RETURN_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_ASYNC_MODE_TYPE","REACT_FORWARD_REF_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","createPortal","children","containerInfo","implementation","key","$$typeof","TouchHistoryMath","centroidDimension","touchesChangedAfter","isXAxis","ofCurrent","total","count","oneTouchData","touchTrack","toAdd","noCentroid","currentCentroidXOfTouchesChangedAfter","currentCentroidYOfTouchesChangedAfter","previousCentroidXOfTouchesChangedAfter","previousCentroidYOfTouchesChangedAfter","currentCentroidX","currentCentroidY","ReactVersion","_classCallCheck","Constructor","TypeError","objects","uniqueID","emptyObject$2","ReactNativePropRegistry","object","id","getByID","emptyObject$1","removedKeys","removedKeyCount","defaultDiffer","prevProp","nextProp","resolveObject","idOrObject","restoreDeletedValuesInNestedArray","updatePayload","node","validAttributes","obj","propKey","_nextProp","attributeConfig","diff","process","nextValue","diffNestedArrayProperty","prevArray","nextArray","minLength","diffNestedProperty","clearNestedProperty","addNestedProperty","diffProperties","addProperties","clearProperties","prevProps","nextProps","shouldUpdate","_nextValue","_propKey","mountSafeCallback","callback","__isMounted","isMounted","throwOnStylesProp","component","styles","owner","_owner","displayName","msg","warnForStyleProps","style","_reactInternalFiber","ReactInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","ReactDebugCurrentFrame","getComponentName","fiber","findHostInstance","findHostInstanceFabric","injectFindHostInstance","impl","findNodeHandle","componentOrHandle","_warnedAboutRefsInRender","render","keys","findNumericNodeHandleFiber","NativeMethodsMixin","measure","measureInWindow","measureLayout","relativeToNativeNode","onSuccess","onFail","setNativeProps","nativeProps","maybeInstance","updateView","uiViewClassName","focus","focusTextInput","blur","blurTextInput","NativeMethodsMixin_DEV","componentWillMount","componentWillReceiveProps","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","newProps","__suppressDeprecationWarning","_classCallCheck$1","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","enumerable","writable","setPrototypeOf","__proto__","ReactNativeComponent","_React$Component","Component","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","DidCapture","Ref","ErrLog","Snapshot","HostEffectMask","Incomplete","ShouldCapture","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","effectTag","isFiberMounted","ownerFiber","assertIsMounted","findCurrentFiberUsingSlowPath","state","parentA","parentB","child","sibling","didFindChild","_child","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberWithNoPortals","MAX_SIGNED_31_BIT_INT","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","expirationTimeToMs","expirationTime","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","NoContext","AsyncMode","StrictMode","hasBadMapPolyfill","nonExtensibleObject","preventExtensions","testMap","Map","testSet","Set","add","debugCounter","FiberNode","pendingProps","mode","ref","memoizedProps","updateQueue","memoizedState","nextEffect","firstEffect","lastEffect","_debugID","_debugSource","_debugOwner","_debugIsCurrentlyTiming","createFiber","shouldConstruct","isReactComponent","createWorkInProgress","workInProgress","createHostRootFiber","isAsync","createFiberFromElement","element","fiberTag","createFiberFromFragment","throwOnInvalidElementType","_source","info","ownerName","elements","createFiberFromText","content","createFiberFromHostInstanceForDeletion","createFiberFromPortal","portal","pendingChildren","assignFiberPropertiesInDEV","source","createFiberRoot","hydrate","uninitializedFiber","root","pendingCommitExpirationTime","finishedWork","pendingContext","remainingExpirationTime","firstBatch","nextScheduledRoot","onCommitFiberRoot","onCommitFiberUnmount","hasLoggedError","catchErrors","err","injectInternals","internals","__REACT_DEVTOOLS_GLOBAL_HOOK__","hook","isDisabled","supportsFiber","rendererID","inject","onCommitRoot","onCommitUnmount","describeComponentFrame","fileName","replace","lineNumber","describeFiber","getStackAddendumByWorkInProgressFiber","lowPriorityWarning","printWarning","format","_len","_key","argIndex","message","x","condition","_len2","_key2","lowPriorityWarning$1","ReactStrictModeWarnings","discardPendingWarnings","flushPendingDeprecationWarnings","flushPendingUnsafeLifecycleWarnings","recordDeprecationWarnings","recordUnsafeLifecycleWarnings","LIFECYCLE_SUGGESTIONS","UNSAFE_componentWillUpdate","pendingComponentWillMountWarnings","pendingComponentWillReceivePropsWarnings","pendingComponentWillUpdateWarnings","pendingUnsafeLifecycleWarnings","didWarnAboutDeprecatedLifecycles","didWarnAboutUnsafeLifecycles","lifecycleWarningsMap","strictRoot","lifecyclesWarningMesages","lifecycle","lifecycleWarnings","componentNames","formatted","suggestion","sortedComponentNames","sort","join","strictRootComponentStack","getStrictRoot","maybeStrictRoot","uniqueNames","sortedNames","_uniqueNames","_sortedNames","_uniqueNames2","_sortedNames2","has","componentWillUpdate","warningsForRoot","unsafeLifecycles","_require","enableGetDerivedStateFromCatch","debugRenderPhaseSideEffects","debugRenderPhaseSideEffectsForStrictMode","warnAboutDeprecatedLifecycles","replayFailedUnitOfWorkWithInvokeGuardedCallback","enableUserTimingAPI","enableMutatingReconciler","enableNoopReconciler","enablePersistentReconciler","getCurrentFiberOwnerName","ReactDebugCurrentFiber","getCurrentFiberStackAddendum","resetCurrentFiber","getCurrentStack","setCurrentFiber","setCurrentPhase","reactEmoji","warningEmoji","supportsUserTiming","performance","mark","clearMarks","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","formatMarkName","markName","formatLabel","label","warning$$1","prefix","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","getFiberMarkName","debugID","getFiberLabel","componentName","beginFiberMark","clearFiberMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startRequestCallbackTimer","stopRequestCallbackTimer","didExpire","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","nextUnitOfWork","stopWorkLoopTimer","interruptedBy","didCompleteRoot","startCommitTimer","clear","stopCommitTimer","startCommitSnapshotEffectsTimer","stopCommitSnapshotEffectsTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","didWarnUpdateInsideUpdate","createUpdateQueue","baseState","queue","first","last","callbackList","hasForceUpdate","isInitialized","capturedValues","isProcessing","insertUpdateIntoQueue","update","q1","q2","ensureUpdateQueues","alternateFiber","queue1","queue2","insertUpdateIntoFiber","getUpdateExpirationTime","getStateFromUpdate","prevState","partialState","processUpdateQueue","renderExpirationTime","currentQueue","dontMutatePrevState","didSkip","updateExpirationTime","_partialState","isReplace","isForced","_callbackList","capturedValue","_capturedValues","commitCallbacks","_callback","fakeInternalInstance","didWarnAboutStateAssignmentForComponent","didWarnAboutUndefinedDerivedState","didWarnAboutUninitializedState","didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate","didWarnAboutLegacyLifecyclesAndDerivedState","warnOnInvalidCallback","didWarnOnInvalidCallback","callerName","callGetDerivedStateFromCatch","ctor","resultState","getDerivedStateFromCatch","ReactFiberClassComponent","legacyContext","scheduleWork","computeExpirationForFiber","memoizeProps","memoizeState","cacheContext","getMaskedContext","getUnmaskedContext","isContextConsumer","hasContextChanged","updater","enqueueSetState","enqueueReplaceState","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","oldState","newState","newContext","shouldComponentUpdate","isPureReactComponent","checkClassInstance","renderPresent","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","contextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","noUnsafeComponentWillRecieveProps","UNSAFE_componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","getSnapshotBeforeUpdate","componentDidUpdate","noInstanceGetDerivedStateFromProps","getDerivedStateFromProps","noInstanceGetDerivedStateFromCatch","noStaticGetSnapshotBeforeUpdate","_state","getChildContext","childContextTypes","resetInputPointers","adoptClassInstance","_reactInternalInstance","constructClassInstance","unmaskedContext","needsContext","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","_componentName","newApiName","callGetDerivedStateFromProps","callComponentWillMount","callComponentWillReceiveProps","mountClassInstance","refs","componentDidMount","resumeMountClassInstance","oldContext","newUnmaskedContext","hasNewLifecycles","derivedStateFromCatch","derivedStateFromProps","_updateQueue","_updateQueue2","updateClassInstance","_updateQueue3","_updateQueue4","getCurrentFiberStackAddendum$1","didWarnAboutMaps","didWarnAboutStringRefInStrictMode","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","coerceRef","returnFiber","mixedRef","stringRef","_stringRef","throwOnInvalidObjectType","newChild","addendum","toString","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","textContent","created","existing","updateElement","updatePortal","updateFragment","fragment","createChild","_created","_created2","_created3","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","reconcileChildrenIterator","newChildrenIterable","iteratorFn","entries","possibleMap","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileSingleTextNode","reconcileSingleElement","_created4","reconcileSinglePortal","reconcileChildFibers","isObject","_isMockFunction","mountChildFibers","cloneChildFibers","currentChild","didWarnAboutBadClass","didWarnAboutGetDerivedStateOnFunctionalComponent","didWarnAboutStatelessRefs","ReactFiberBeginWork","config","hostContext","hydrationContext","shouldSetTextContent","shouldDeprioritizeSubtree","pushHostContext","pushHostContainer","pushProvider","hasLegacyContextChanged","pushLegacyContextProvider","pushContextProvider","pushTopLevelContextObject","invalidateContextProvider","enterHydrationState","resetHydrationState","tryToClaimNextHydratableInstance","_ReactFiberClassCompo","reconcileChildren","nextChildren","reconcileChildrenAtExpirationTime","updateForwardRef","bailoutOnAlreadyFinishedWork","updateMode","markRef","updateFunctionalComponent","updateClassComponent","hasContext","didCaptureError","finishClassComponent","pushHostRootContext","updateHostRoot","updateHostComponent","isHidden","isDirectTextChild","updateHostText","mountIndeterminateComponent","_Component","warningKey","debugSource","updateCallComponent","updatePortalComponent","propagateContextChange","changedBits","nextFiber","observedBits","updateContextProvider","providerType","_context","newValue","oldValue","_calculateChangedBits","updateContextConsumer","_currentValue","_changedBits","unstable_observedBits","bailoutOnLowPriority","nextState","beginWork","ReactFiberCompleteWork","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","mutation","persistence","getRootHostContainer","popHostContext","getHostContext","popHostContainer","popLegacyContextProvider","popContextProvider","popTopLevelLegacyContextObject","popTopLevelContextObject","popProvider","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popHydrationState","markUpdate","appendAllReturns","returns","moveCallToHandlerPhase","handler","childProps","appendAllChildren","updateHostContainer","rootContainerInstance","currentHostContext","oldText","newText","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","completeWork","componentDidCatch","fiberRoot","_instance","_currentHostContext","wasHydrated","_instance2","_rootContainerInstance","_currentHostContext2","_wasHydrated","createCapturedValue","stack","ReactFiberUnwindWork","isAlreadyFailedLegacyErrorBoundary","throwException","sourceFiber","rawValue","errorInfo","unwindWork","_effectTag","unwindInterruptedWork","interruptedWork","showErrorDialog","capturedError","componentStack","errorToHandle","summary","handleException","logCapturedError","logError","suppressLogging","suppressReactErrorLogging","errorBoundaryName","errorBoundaryFound","willRetry","componentNameMessage","errorBoundaryMessage","combinedMessage","invokeGuardedCallback$3","hasCaughtError$1","clearCaughtError$1","didWarnAboutUndefinedSnapshotBeforeUpdate","boundary","errorBoundary","ReactFiberCommitWork","captureError","markLegacyErrorBoundaryAsFailed","recalculateCurrentTime","getPublicInstance","callComponentWillUnmountWithTimer","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","safelyDetachRef","refError","commitBeforeMutationLifeCycles","snapshot","didWarnSet","__reactInternalSnapshotBeforeUpdate","commitLifeCycles","finishedRoot","committedExpirationTime","_instance3","_instance4","commitMount","commitErrorLogging","onUncaughtError","_instance5","capturedErrors","_error","_capturedErrors","_i","_errorInfo","commitAttachRef","_instance6","instanceToUse","commitDetachRef","currentRef","commitUnmount","_instance7","commitNestedUnmounts","unmountHostComponents","emptyPortalContainer","detachFiber","commitContainer","replaceContainerChildren","emptyChildSet","_pendingChildren","commitResetTextContent","commitPlacement","commitDeletion","commitWork","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","getHostParentFiber","isHostParent","getHostSibling","siblings","parentFiber","isContainer","before","currentParentIsValid","currentParentIsContainer","findParent","_instance8","textInstance","NO_CONTEXT","ReactFiberHostContext","getChildHostContext","getRootHostContext","createCursor","contextStackCursor","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","rootInstance","nextRootInstance","nextRootContext","nextContext","ReactFiberHydrationContext","hydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","hydrationParentFiber","nextHydratableInstance","isHydrating","parentInstance","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","text","parentType","parentProps","_type","_props","_text","tryHydrate","nextInstance","popToNextHostParent","ReactFiberInstrumentation","debugTool","ReactFiberInstrumentation_1","warnedAboutMissingGetChildContext","ReactFiberLegacyContext","didPerformWorkStackCursor","previousContext","hasOwnContext","isContextProvider","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","didChange","cursor","processChildContext","parentContext","childContext","contextKey","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","mergedContext","findCurrentUnmaskedContext","ReactFiberNewContext","providerCursor","valueCursor","changedBitsCursor","rendererSigil","providerFiber","_currentRenderer","currentValue","ReactFiberStack","valueStack","fiberStack","defaultValue","isEmpty","checkThatStackIsEmpty","resetStackAfterFatalErrorInDev","invokeGuardedCallback$2","didWarnAboutStateTransition","didWarnSetStateChildContext","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","didWarnStateUpdateForUnmountedComponent","ReactFiberScheduler","_ReactFiberBeginWork","_ReactFiberCompleteWo","_ReactFiberUnwindWork","_ReactFiberCommitWork","onCommitPhaseError","scheduleDeferredCallback","cancelDeferredCallback","prepareForCommit","resetAfterCommit","originalStartTimeMs","mostRecentCurrentTime","mostRecentCurrentTimeMs","lastUniqueAsyncExpiration","expirationContext","isWorking","nextRoot","nextRenderExpirationTime","isRootReadyForCommit","legacyErrorBoundariesThatAlreadyFailed","stashedWorkInProgressProperties","replayUnitOfWork","isReplayingFailedUnitOfWork","originalReplayError","rethrowOriginalError","failedUnitOfWork","workLoop","resetStack","commitAllHostEffects","primaryEffectTag","_current","_current2","commitBeforeMutationLifecycles","commitAllLifeCycles","commitRoot","_didError","_didError2","_error2","onCommitWork","remainingTime","resetExpirationTime","renderTime","newExpirationTime","completeUnitOfWork","siblingFiber","onCompleteWork","_next","performUnitOfWork","onBeginWork","shouldYield","renderRoot","didFatal","thrownValue","scheduleCapture","boundaryFiber","dispatch","computeAsyncExpiration","expirationMs","computeInteractiveExpiration","computeUniqueAsyncExpiration","isBatchingInteractiveUpdates","_currentTime","lowestPendingInteractiveExpirationTime","scheduleWorkImpl","isErrorRecovery","requestWork","nestedUpdateCount","NESTED_UPDATE_LIMIT","deferredUpdates","previousExpirationContext","syncUpdates","firstScheduledRoot","lastScheduledRoot","callbackExpirationTime","callbackID","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","hasUnhandledError","unhandledError","deadline","isBatchingUpdates","isUnbatchingUpdates","completedBatches","timeHeuristicForUnitOfWork","scheduleCallbackWithExpiration","currentMs","timeout","performAsyncWork","addRootToSchedule","performWorkOnRoot","performSyncWork","findHighestPriorityRoot","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","previousFlushedRoot","dl","performWork","minExpirationTime","finishRendering","flushRoot","batches","batch","_onComplete","completeRoot","_finishedWork","_expirationTime","_defer","timeRemaining","previousIsBatchingUpdates","unbatchedUpdates","flushSync","previousIsBatchingInteractiveUpdates","flushControlled","didWarnAboutNestedUpdates","ReactFiberReconciler$1","_ReactFiberScheduler","getContextForSubtree","parentComponent","scheduleRootUpdate","updateContainerAtExpirationTime","onMountContainer","onUnmountContainer","onUpdateContainer","hostFiber","createContainer","updateContainer","getPublicRootInstance","containerFiber","findHostInstanceWithNoPortals","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","findHostInstanceByFiber","ReactFiberReconciler$2","default","ReactFiberReconciler$3","reactReconciler","viewConfigCallbacks","viewConfigs","get$1","_classCallCheck$2","ReactNativeFiberHostComponent","_children","hasNativePerformanceNow","scheduledCallback","frameDeadline","frameDeadlineObject","didTimeout","setTimeoutCallback","setTimeout","clearTimeout","recursivelyUncacheFiberNode","NativeRenderer","internalInstanceHandle","createView","nativeTags","map","setChildren","childTag","splice","manageChildren","updatePayloadTODO","beforeChild","beforeChildIndex","_beforeChildIndex","getInspectorDataForViewTag","traverseOwnerTreeUp","hierarchy","unshift","getOwnerHierarchy","lastNonHostInstance","getHostProps","host","getHostNode","hostNode","createHierarchy","fiberHierarchy","getInspectorData","viewTag","closestInstance","selection","createReactNativeComponentClass","takeSnapshot","view","options","__takeSnapshot","roots","ReactNativeRenderer","NativeComponent","containerTag","unmountComponentAtNode","unmountComponentAtNodeAndRemoveContainer","removeRootView","unstable_batchedUpdates","ReactDebugTool","addHook","removeHook","ReactPerf","start","stop","printInclusive","printWasted","bundleType","version","rendererPackageName","ReactNativeRenderer$2","ReactNativeRenderer$3","reactNativeRenderer","module","exports"],"mappings":"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","file":"ReactNativeRenderer-dev.js","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n * @providesModule ReactNativeRenderer-dev\n * @preventMunge\n */\n\n'use strict';\n\nif (__DEV__) {\n  (function() {\n\"use strict\";\n\nrequire(\"InitializeCore\");\nvar invariant = require(\"fbjs/lib/invariant\");\nvar warning = require(\"fbjs/lib/warning\");\nvar emptyFunction = require(\"fbjs/lib/emptyFunction\");\nvar UIManager = require(\"UIManager\");\nvar RCTEventEmitter = require(\"RCTEventEmitter\");\nvar TextInputState = require(\"TextInputState\");\nvar deepDiffer = require(\"deepDiffer\");\nvar flattenStyle = require(\"flattenStyle\");\nvar React = require(\"react\");\nvar emptyObject = require(\"fbjs/lib/emptyObject\");\nvar shallowEqual = require(\"fbjs/lib/shallowEqual\");\nvar ExceptionsManager = require(\"ExceptionsManager\");\nvar checkPropTypes = require(\"prop-types/checkPropTypes\");\nvar deepFreezeAndThrowOnMutationInDev = require(\"deepFreezeAndThrowOnMutationInDev\");\n\nvar invokeGuardedCallback = function(name, func, context, a, b, c, d, e, f) {\n  this._hasCaughtError = false;\n  this._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this._caughtError = error;\n    this._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.dispatchEvent === \"function\" &&\n    typeof document !== \"undefined\" &&\n    typeof document.createEvent === \"function\"\n  ) {\n    var fakeNode = document.createElement(\"react\");\n\n    var invokeGuardedCallbackDev = function(\n      name,\n      func,\n      context,\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    ) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      invariant(\n        typeof document !== \"undefined\",\n        \"The `document` global was defined when React was initialized, but is not \" +\n          \"defined anymore. This can happen in a test environment if a component \" +\n          \"schedules an update from an asynchronous callback, but the test has already \" +\n          \"finished running. To solve this, you can either unmount the component at \" +\n          \"the end of your test (and ensure that any asynchronous operations get \" +\n          \"canceled in `componentWillUnmount`), or you can change the test itself \" +\n          \"to be asynchronous.\"\n      );\n      var evt = document.createEvent(\"Event\");\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n\n      // Attach our event handlers\n      window.addEventListener(\"error\", onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error(\n            \"An error was thrown inside one of your components, but React \" +\n              \"doesn't know what it was. This is likely due to browser \" +\n              'flakiness. React does its best to preserve the \"Pause on ' +\n              'exceptions\" behavior of the DevTools, which requires some ' +\n              \"DEV-mode only tricks. It's possible that these don't work in \" +\n              \"your browser. Try triggering the error in production mode, \" +\n              \"or switching to a modern browser. If you suspect that this is \" +\n              \"actually an issue with React, please file an issue.\"\n          );\n        } else if (isCrossOriginError) {\n          error = new Error(\n            \"A cross-origin error was thrown. React doesn't have access to \" +\n              \"the actual error object in development. \" +\n              \"See https://fb.me/react-crossorigin-error for more information.\"\n          );\n        }\n        this._hasCaughtError = true;\n        this._caughtError = error;\n      } else {\n        this._hasCaughtError = false;\n        this._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener(\"error\", onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallback$1 = invokeGuardedCallback;\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function(name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function(\n    name,\n    func,\n    context,\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  ) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function() {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function() {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function() {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(\n        false,\n        \"clearCaughtError was called but no error was captured. This error \" +\n          \"is likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n};\n\nvar rethrowCaughtError = function() {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    invariant(\n      pluginIndex > -1,\n      \"EventPluginRegistry: Cannot inject event plugins that do not exist in \" +\n        \"the plugin ordering, `%s`.\",\n      pluginName\n    );\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    invariant(\n      pluginModule.extractEvents,\n      \"EventPluginRegistry: Event plugins must implement an `extractEvents` \" +\n        \"method, but `%s` does not.\",\n      pluginName\n    );\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      invariant(\n        publishEventForPlugin(\n          publishedEvents[eventName],\n          pluginModule,\n          eventName\n        ),\n        \"EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\",\n        eventName,\n        pluginName\n      );\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  invariant(\n    !eventNameDispatchConfigs.hasOwnProperty(eventName),\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"event name, `%s`.\",\n    eventName\n  );\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(\n          phasedRegistrationName,\n          pluginModule,\n          eventName\n        );\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(\n      dispatchConfig.registrationName,\n      pluginModule,\n      eventName\n    );\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  invariant(\n    !registrationNameModules[registrationName],\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"registration name, `%s`.\",\n    registrationName\n  );\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] =\n    pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\n\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  invariant(\n    !eventPluginOrder,\n    \"EventPluginRegistry: Cannot inject event plugin ordering more than \" +\n      \"once. You are likely trying to load more than one copy of React.\"\n  );\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (\n      !namesToPlugins.hasOwnProperty(pluginName) ||\n      namesToPlugins[pluginName] !== pluginModule\n    ) {\n      invariant(\n        !namesToPlugins[pluginName],\n        \"EventPluginRegistry: Cannot inject two different event plugins \" +\n          \"using the same name, `%s`.\",\n        pluginName\n      );\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$1 = {\n  injectComponentTree: function(Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      !(getNodeFromInstance && getInstanceFromNode)\n        ? warning(\n            false,\n            \"EventPluginUtils.injection.injectComponentTree(...): Injected \" +\n              \"module is missing getNodeFromInstance or getInstanceFromNode.\"\n          )\n        : void 0;\n    }\n  }\n};\n\nfunction isEndish(topLevelType) {\n  return (\n    topLevelType === \"topMouseUp\" ||\n    topLevelType === \"topTouchEnd\" ||\n    topLevelType === \"topTouchCancel\"\n  );\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === \"topMouseMove\" || topLevelType === \"topTouchMove\";\n}\nfunction isStartish(topLevelType) {\n  return topLevelType === \"topMouseDown\" || topLevelType === \"topTouchStart\";\n}\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr\n      ? dispatchListeners.length\n      : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr\n      ? dispatchInstances.length\n      : dispatchInstances ? 1 : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen)\n      ? warning(false, \"EventPluginUtils: Invalid `event`.\")\n      : void 0;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || \"unknown-event\";\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(\n    type,\n    listener,\n    undefined,\n    event\n  );\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(\n        event,\n        simulated,\n        dispatchListeners[i],\n        dispatchInstances[i]\n      );\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n  invariant(\n    !Array.isArray(dispatchListener),\n    \"executeDirectDispatch(...): Invalid `event`.\"\n  );\n  event.currentTarget = dispatchListener\n    ? getNodeFromInstance(dispatchInstance)\n    : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  invariant(\n    next != null,\n    \"accumulateInto(...): Accumulated items must not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function(event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function(e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function(e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return (\n    tag === \"button\" ||\n    tag === \"input\" ||\n    tag === \"select\" ||\n    tag === \"textarea\"\n  );\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case \"onClick\":\n    case \"onClickCapture\":\n    case \"onDoubleClick\":\n    case \"onDoubleClickCapture\":\n    case \"onMouseDown\":\n    case \"onMouseDownCapture\":\n    case \"onMouseMove\":\n    case \"onMouseMoveCapture\":\n    case \"onMouseUp\":\n    case \"onMouseUpCapture\":\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  invariant(\n    !listener || typeof listener === \"function\",\n    \"Expected `%s` listener to be a function, instead got a value of `%s` type.\",\n    registrationName,\n    typeof listener\n  );\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(\n        topLevelType,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseSimulated\n    );\n  } else {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseTopLevel\n    );\n  }\n  invariant(\n    !eventQueue,\n    \"processEventQueue(): Additional events were enqueued while processing \" +\n      \"an event queue. Support for this has not yet been implemented.\"\n  );\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = extractEvents(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  runEventsInBatch(events, false);\n}\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\nvar Mode = 11;\nvar ContextConsumer = 12;\nvar ContextProvider = 13;\nvar ForwardRef = 14;\n\nfunction getParent(inst) {\n  do {\n    inst = inst[\"return\"];\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0; ) {\n    fn(path[i], \"captured\", arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], \"bubbled\", arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst ? warning(false, \"Dispatching inst must not be null\") : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(\n        event._dispatchListeners,\n        listener\n      );\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = [\n  \"dispatchConfig\",\n  \"_targetInst\",\n  \"nativeEvent\",\n  \"isDefaultPrevented\",\n  \"isPropagationStopped\",\n  \"_dispatchListeners\",\n  \"_dispatchInstances\"\n];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function(event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(\n  dispatchConfig,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === \"target\") {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented =\n    nativeEvent.defaultPrevented != null\n      ? nativeEvent.defaultPrevented\n      : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\nObject.assign(SyntheticEvent.prototype, {\n  preventDefault: function() {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== \"unknown\") {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function() {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== \"unknown\") {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function() {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function() {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(\n          this,\n          propName,\n          getPooledWarningPropertyDefinition(propName, Interface[propName])\n        );\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(\n        this,\n        \"nativeEvent\",\n        getPooledWarningPropertyDefinition(\"nativeEvent\", null)\n      );\n      Object.defineProperty(\n        this,\n        \"preventDefault\",\n        getPooledWarningPropertyDefinition(\"preventDefault\", emptyFunction)\n      );\n      Object.defineProperty(\n        this,\n        \"stopPropagation\",\n        getPooledWarningPropertyDefinition(\"stopPropagation\", emptyFunction)\n      );\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function(Interface) {\n  var Super = this;\n\n  var E = function() {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  Object.assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = Object.assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  var isProxySupported =\n    typeof Proxy === \"function\" &&\n    // https://github.com/facebook/react/issues/12011\n    !Object.isSealed(new Proxy({}, {}));\n\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function(target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function(constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function(target, prop, value) {\n            if (\n              prop !== \"isPersistent\" &&\n              !target.constructor.Interface.hasOwnProperty(prop) &&\n              shouldBeReleasedProperties.indexOf(prop) === -1\n            ) {\n              !(didWarnForAddedNewProperty || target.isPersistent())\n                ? warning(\n                    false,\n                    \"This synthetic event is reused for performance reasons. If you're \" +\n                      \"seeing this, you're adding a new property in the synthetic event object. \" +\n                      \"The property is never released. See \" +\n                      \"https://fb.me/react-event-pooling for more information.\"\n                  )\n                : void 0;\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === \"function\";\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? \"setting the method\" : \"setting the property\";\n    warn(action, \"This is effectively a no-op\");\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? \"accessing the method\" : \"accessing the property\";\n    var result = isFunction\n      ? \"This is a no-op function\"\n      : \"This is set to null\";\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition\n      ? warning(\n          false,\n          \"This synthetic event is reused for performance reasons. If you're seeing this, \" +\n            \"you're %s `%s` on a released/nullified synthetic event. %s. \" +\n            \"If you must keep the original synthetic event around, use event.persist(). \" +\n            \"See https://fb.me/react-event-pooling for more information.\",\n          action,\n          propName,\n          result\n        )\n      : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(\n      instance,\n      dispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeInst\n    );\n    return instance;\n  }\n  return new EventConstructor(\n    dispatchConfig,\n    targetInst,\n    nativeEvent,\n    nativeInst\n  );\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  invariant(\n    event instanceof EventConstructor,\n    \"Trying to release an event instance  into a pool of a different type.\"\n  );\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\nvar ResponderSyntheticEvent = SyntheticEvent$1.extend({\n  touchHistory: function(nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n});\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  invariant(identifier != null, \"Touch object is missing identifier.\");\n  {\n    !(identifier <= MAX_TOUCH_BANK)\n      ? warning(\n          false,\n          \"Touch identifier %s is greater than maximum supported %s which causes \" +\n            \"performance issues backfilling array locations for all of the indices.\",\n          identifier,\n          MAX_TOUCH_BANK\n        )\n      : void 0;\n  }\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch move without a touch start.\\n\" + \"Touch Move: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch end without a touch start.\\n\" + \"Touch End: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += \" (original size: \" + touchBank.length + \")\";\n  }\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function(topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch =\n          nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          !(activeRecord != null && activeRecord.touchActive)\n            ? warning(false, \"Cannot find single active touch.\")\n            : void 0;\n        }\n      }\n    }\n  },\n\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\nfunction accumulate(current, next) {\n  invariant(\n    next != null,\n    \"accumulate(...): Accumulated items must be not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\nvar responderInst = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\n/**\n * Last reported number of active touches.\n */\nvar previousActiveTouches = 0;\n\nvar changeResponder = function(nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(\n      oldResponderInst,\n      nextResponderInst,\n      blockHostResponder\n    );\n  }\n};\n\nvar eventTypes = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onStartShouldSetResponder\",\n      captured: \"onStartShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onScrollShouldSetResponder\",\n      captured: \"onScrollShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onSelectionChangeShouldSetResponder\",\n      captured: \"onSelectionChangeShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onMoveShouldSetResponder\",\n      captured: \"onMoveShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: { registrationName: \"onResponderStart\" },\n  responderMove: { registrationName: \"onResponderMove\" },\n  responderEnd: { registrationName: \"onResponderEnd\" },\n  responderRelease: { registrationName: \"onResponderRelease\" },\n  responderTerminationRequest: {\n    registrationName: \"onResponderTerminationRequest\"\n  },\n  responderGrant: { registrationName: \"onResponderGrant\" },\n  responderReject: { registrationName: \"onResponderReject\" },\n  responderTerminate: { registrationName: \"onResponderTerminate\" }\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var shouldSetEventType = isStartish(topLevelType)\n    ? eventTypes.startShouldSetResponder\n    : isMoveish(topLevelType)\n      ? eventTypes.moveShouldSetResponder\n      : topLevelType === \"topSelectionChange\"\n        ? eventTypes.selectionChangeShouldSetResponder\n        : eventTypes.scrollShouldSetResponder;\n\n  // TODO: stop one short of the current responder.\n  var bubbleShouldSetFrom = !responderInst\n    ? targetInst\n    : getLowestCommonAncestor(responderInst, targetInst);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(\n    shouldSetEventType,\n    bubbleShouldSetFrom,\n    nativeEvent,\n    nativeEventTarget\n  );\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n  var extracted = void 0;\n  var grantEvent = ResponderSyntheticEvent.getPooled(\n    eventTypes.responderGrant,\n    wantsResponderInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(\n      eventTypes.responderTerminationRequest,\n      responderInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    terminationRequestEvent.touchHistory =\n      ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch =\n      !hasDispatches(terminationRequestEvent) ||\n      executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes.responderTerminate,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes.responderReject,\n        wantsResponderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return (\n    topLevelInst &&\n    // responderIgnoreScroll: We are trying to migrate away from specifically\n    // tracking native scroll events here and responderIgnoreScroll indicates we\n    // will send topTouchCancel to handle canceling touch events instead\n    ((topLevelType === \"topScroll\" && !nativeEvent.responderIgnoreScroll) ||\n      (trackedTouchCount > 0 && topLevelType === \"topSelectionChange\") ||\n      isStartish(topLevelType) ||\n      isMoveish(topLevelType))\n  );\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode(target);\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function() {\n    return responderInst;\n  },\n\n  eventTypes: eventTypes,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.error(\n          \"Ended a touch event which was not counted in `trackedTouchCount`.\"\n        );\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)\n      ? setResponderAndExtractTransfer(\n          topLevelType,\n          targetInst,\n          nativeEvent,\n          nativeEventTarget\n        )\n      : null;\n    // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart\n      ? eventTypes.responderStart\n      : isResponderTouchMove\n        ? eventTypes.responderMove\n        : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(\n        incrementalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate =\n      responderInst && topLevelType === \"topTouchCancel\";\n    var isResponderRelease =\n      responderInst &&\n      !isResponderTerminate &&\n      isEndish(topLevelType) &&\n      noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate\n      ? eventTypes.responderTerminate\n      : isResponderRelease ? eventTypes.responderRelease : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(\n        finalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    var numberActiveTouches =\n      ResponderTouchHistoryStore.touchHistory.numberActiveTouches;\n    if (\n      ResponderEventPlugin.GlobalInteractionHandler &&\n      numberActiveTouches !== previousActiveTouches\n    ) {\n      ResponderEventPlugin.GlobalInteractionHandler.onChange(\n        numberActiveTouches\n      );\n    }\n    previousActiveTouches = numberActiveTouches;\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n  GlobalInteractionHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function(GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    },\n\n    /**\n     * @param {{onChange: (numberActiveTouches) => void} GlobalInteractionHandler\n     * Object that handles any change in the number of active touches.\n     */\n    injectGlobalInteractionHandler: function(GlobalInteractionHandler) {\n      ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;\n    }\n  }\n};\n\nvar customBubblingEventTypes = {};\nvar customDirectEventTypes = {};\n\nvar ReactNativeBridgeEventPlugin = {\n  eventTypes: {},\n\n  /**\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (targetInst == null) {\n      // Probably a node belonging to another renderer's tree.\n      return null;\n    }\n    var bubbleDispatchConfig = customBubblingEventTypes[topLevelType];\n    var directDispatchConfig = customDirectEventTypes[topLevelType];\n    invariant(\n      bubbleDispatchConfig || directDispatchConfig,\n      'Unsupported top level event type \"%s\" dispatched',\n      topLevelType\n    );\n    var event = SyntheticEvent$1.getPooled(\n      bubbleDispatchConfig || directDispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    if (bubbleDispatchConfig) {\n      accumulateTwoPhaseDispatches(event);\n    } else if (directDispatchConfig) {\n      accumulateDirectDispatches(event);\n    } else {\n      return null;\n    }\n    return event;\n  },\n\n  processEventTypes: function(viewConfig) {\n    var bubblingEventTypes = viewConfig.bubblingEventTypes,\n      directEventTypes = viewConfig.directEventTypes;\n\n    {\n      if (bubblingEventTypes != null && directEventTypes != null) {\n        for (var topLevelType in directEventTypes) {\n          invariant(\n            bubblingEventTypes[topLevelType] == null,\n            \"Event cannot be both direct and bubbling: %s\",\n            topLevelType\n          );\n        }\n      }\n    }\n\n    if (bubblingEventTypes != null) {\n      for (var _topLevelType in bubblingEventTypes) {\n        if (customBubblingEventTypes[_topLevelType] == null) {\n          ReactNativeBridgeEventPlugin.eventTypes[\n            _topLevelType\n          ] = customBubblingEventTypes[_topLevelType] =\n            bubblingEventTypes[_topLevelType];\n        }\n      }\n    }\n\n    if (directEventTypes != null) {\n      for (var _topLevelType2 in directEventTypes) {\n        if (customDirectEventTypes[_topLevelType2] == null) {\n          ReactNativeBridgeEventPlugin.eventTypes[\n            _topLevelType2\n          ] = customDirectEventTypes[_topLevelType2] =\n            directEventTypes[_topLevelType2];\n        }\n      }\n    }\n  }\n};\n\nvar instanceCache = {};\nvar instanceProps = {};\n\nfunction precacheFiberNode(hostInst, tag) {\n  instanceCache[tag] = hostInst;\n}\n\nfunction uncacheFiberNode(tag) {\n  delete instanceCache[tag];\n  delete instanceProps[tag];\n}\n\nfunction getInstanceFromTag(tag) {\n  if (typeof tag === \"number\") {\n    return instanceCache[tag] || null;\n  } else {\n    // Fabric will invoke event emitters on a direct fiber reference\n    return tag;\n  }\n}\n\nfunction getTagFromInstance(inst) {\n  var tag = inst.stateNode._nativeTag;\n  if (tag === undefined) {\n    tag = inst.stateNode.canonical._nativeTag;\n  }\n  invariant(tag, \"All native instances should have a tag.\");\n  return tag;\n}\n\nfunction getFiberCurrentPropsFromNode$1(stateNode) {\n  return instanceProps[stateNode._nativeTag] || null;\n}\n\nfunction updateFiberProps(tag, props) {\n  instanceProps[tag] = props;\n}\n\nvar ReactNativeComponentTree = Object.freeze({\n  precacheFiberNode: precacheFiberNode,\n  uncacheFiberNode: uncacheFiberNode,\n  getClosestInstanceFromNode: getInstanceFromTag,\n  getInstanceFromNode: getInstanceFromTag,\n  getNodeFromInstance: getTagFromInstance,\n  getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n  updateFiberProps: updateFiberProps\n});\n\nvar ReactNativeEventPluginOrder = [\n  \"ResponderEventPlugin\",\n  \"ReactNativeBridgeEventPlugin\"\n];\n\n// Module provided by RN:\nvar ReactNativeGlobalResponderHandler = {\n  onChange: function(from, to, blockNativeResponder) {\n    if (to !== null) {\n      var tag = to.stateNode._nativeTag;\n      UIManager.setJSResponder(tag, blockNativeResponder);\n    } else {\n      UIManager.clearJSResponder();\n    }\n  }\n};\n\n/**\n * Make sure essential globals are available and are patched correctly. Please don't remove this\n * line. Bundles created by react-packager `require` it before executing any application code. This\n * ensures it exists in the dependency graph and can be `require`d.\n * TODO: require this in packager, not in React #10932517\n */\n// Module provided by RN:\n/**\n * Inject module for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(ReactNativeEventPluginOrder);\ninjection$1.injectComponentTree(ReactNativeComponentTree);\n\nResponderEventPlugin.injection.injectGlobalResponderHandler(\n  ReactNativeGlobalResponderHandler\n);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  ResponderEventPlugin: ResponderEventPlugin,\n  ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin\n});\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  invariant(\n    fiberHostComponent &&\n      typeof fiberHostComponent.restoreControlledState === \"function\",\n    \"Fiber needs to be injected to handle a fiber target for controlled \" +\n      \"events. This error is likely caused by a bug in React. Please file an issue.\"\n  );\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(\n    internalInstance.stateNode,\n    internalInstance.type,\n    props\n  );\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdates = function(fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _interactiveUpdates = function(fn, a, b) {\n  return fn(a, b);\n};\nvar _flushInteractiveUpdates = function() {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdates();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nvar injection$2 = {\n  injectRenderer: function(renderer) {\n    _batchedUpdates = renderer.batchedUpdates;\n    _interactiveUpdates = renderer.interactiveUpdates;\n    _flushInteractiveUpdates = renderer.flushInteractiveUpdates;\n  }\n};\n\n/**\n * Keeps track of allocating and associating native \"tags\" which are numeric,\n * unique view IDs. All the native tags are negative numbers, to avoid\n * collisions, but in the JS we keep track of them as positive integers to store\n * them effectively in Arrays. So we must refer to them as \"inverses\" of the\n * native tags (that are * normally negative).\n *\n * It *must* be the case that every `rootNodeID` always maps to the exact same\n * `tag` forever. The easiest way to accomplish this is to never delete\n * anything from this table.\n * Why: Because `dangerouslyReplaceNodeWithMarkupByID` relies on being able to\n * unmount a component with a `rootNodeID`, then mount a new one in its place,\n */\nvar INITIAL_TAG_COUNT = 1;\nvar ReactNativeTagHandles = {\n  tagsStartAt: INITIAL_TAG_COUNT,\n  tagCount: INITIAL_TAG_COUNT,\n\n  allocateTag: function() {\n    // Skip over root IDs as those are reserved for native\n    while (this.reactTagIsNativeTopRootID(ReactNativeTagHandles.tagCount)) {\n      ReactNativeTagHandles.tagCount++;\n    }\n    var tag = ReactNativeTagHandles.tagCount;\n    ReactNativeTagHandles.tagCount++;\n    return tag;\n  },\n\n  assertRootTag: function(tag) {\n    invariant(\n      this.reactTagIsNativeTopRootID(tag),\n      \"Expect a native root tag, instead got %s\",\n      tag\n    );\n  },\n\n  reactTagIsNativeTopRootID: function(reactTag) {\n    // We reserve all tags that are 1 mod 10 for native root views\n    return reactTag % 10 === 1;\n  }\n};\n\n/**\n * Version of `ReactBrowserEventEmitter` that works on the receiving side of a\n * serialized worker boundary.\n */\n\n// Shared default empty native event - conserve memory.\nvar EMPTY_NATIVE_EVENT = {};\n\n/**\n * Selects a subsequence of `Touch`es, without destroying `touches`.\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices by which to pull subsequence.\n * @return {Array<Touch>} Subsequence of touch objects.\n */\nvar touchSubsequence = function(touches, indices) {\n  var ret = [];\n  for (var i = 0; i < indices.length; i++) {\n    ret.push(touches[indices[i]]);\n  }\n  return ret;\n};\n\n/**\n * TODO: Pool all of this.\n *\n * Destroys `touches` by removing touch objects at indices `indices`. This is\n * to maintain compatibility with W3C touch \"end\" events, where the active\n * touches don't include the set that has just been \"ended\".\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices to remove from `touches`.\n * @return {Array<Touch>} Subsequence of removed touch objects.\n */\nvar removeTouchesAtIndices = function(touches, indices) {\n  var rippedOut = [];\n  // use an unsafe downcast to alias to nullable elements,\n  // so we can delete and then compact.\n  var temp = touches;\n  for (var i = 0; i < indices.length; i++) {\n    var index = indices[i];\n    rippedOut.push(touches[index]);\n    temp[index] = null;\n  }\n  var fillAt = 0;\n  for (var j = 0; j < temp.length; j++) {\n    var cur = temp[j];\n    if (cur !== null) {\n      temp[fillAt++] = cur;\n    }\n  }\n  temp.length = fillAt;\n  return rippedOut;\n};\n\n/**\n * Internal version of `receiveEvent` in terms of normalized (non-tag)\n * `rootNodeID`.\n *\n * @see receiveEvent.\n *\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {?object} nativeEventParam Object passed from native.\n */\nfunction _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {\n  var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;\n  var inst = getInstanceFromTag(rootNodeID);\n  batchedUpdates(function() {\n    runExtractedEventsInBatch(\n      topLevelType,\n      inst,\n      nativeEvent,\n      nativeEvent.target\n    );\n  });\n  // React Native doesn't use ReactControlledComponent but if it did, here's\n  // where it would do it.\n}\n\n/**\n * Publicly exposed method on module for native objc to invoke when a top\n * level event is extracted.\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {object} nativeEventParam Object passed from native.\n */\nfunction receiveEvent(rootNodeID, topLevelType, nativeEventParam) {\n  _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);\n}\n\n/**\n * Simple multi-wrapper around `receiveEvent` that is intended to receive an\n * efficient representation of `Touch` objects, and other information that\n * can be used to construct W3C compliant `Event` and `Touch` lists.\n *\n * This may create dispatch behavior that differs than web touch handling. We\n * loop through each of the changed touches and receive it as a single event.\n * So two `touchStart`/`touchMove`s that occur simultaneously are received as\n * two separate touch event dispatches - when they arguably should be one.\n *\n * This implementation reuses the `Touch` objects themselves as the `Event`s\n * since we dispatch an event for each touch (though that might not be spec\n * compliant). The main purpose of reusing them is to save allocations.\n *\n * TODO: Dispatch multiple changed touches in one event. The bubble path\n * could be the first common ancestor of all the `changedTouches`.\n *\n * One difference between this behavior and W3C spec: cancelled touches will\n * not appear in `.touches`, or in any future `.touches`, though they may\n * still be \"actively touching the surface\".\n *\n * Web desktop polyfills only need to construct a fake touch event with\n * identifier 0, also abandoning traditional click handlers.\n */\nfunction receiveTouches(eventTopLevelType, touches, changedIndices) {\n  var changedTouches =\n    eventTopLevelType === \"topTouchEnd\" ||\n    eventTopLevelType === \"topTouchCancel\"\n      ? removeTouchesAtIndices(touches, changedIndices)\n      : touchSubsequence(touches, changedIndices);\n\n  for (var jj = 0; jj < changedTouches.length; jj++) {\n    var touch = changedTouches[jj];\n    // Touch objects can fulfill the role of `DOM` `Event` objects if we set\n    // the `changedTouches`/`touches`. This saves allocations.\n    touch.changedTouches = changedTouches;\n    touch.touches = touches;\n    var nativeEvent = touch;\n    var rootNodeID = null;\n    var target = nativeEvent.target;\n    if (target !== null && target !== undefined) {\n      if (target < ReactNativeTagHandles.tagsStartAt) {\n        {\n          warning(\n            false,\n            \"A view is reporting that a touch occurred on tag zero.\"\n          );\n        }\n      } else {\n        rootNodeID = target;\n      }\n    }\n    // $FlowFixMe Shouldn't we *not* call it if rootNodeID is null?\n    _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);\n  }\n}\n\nvar ReactNativeEventEmitter = Object.freeze({\n  getListener: getListener,\n  registrationNames: registrationNameModules,\n  _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,\n  receiveEvent: receiveEvent,\n  receiveTouches: receiveTouches\n});\n\n// Module provided by RN:\n/**\n * Register the event emitter with the native bridge\n */\nRCTEventEmitter.register(ReactNativeEventEmitter);\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === \"function\" && Symbol[\"for\"];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.element\") : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.call\") : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol[\"for\"](\"react.return\") : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.portal\") : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.fragment\") : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol[\"for\"](\"react.strict_mode\")\n  : 0xeacc;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol[\"for\"](\"react.provider\") : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.context\") : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol\n  ? Symbol[\"for\"](\"react.async_mode\")\n  : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol\n  ? Symbol[\"for\"](\"react.forward_ref\")\n  : 0xead0;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === \"undefined\") {\n    return null;\n  }\n  var maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === \"function\") {\n    return maybeIterator;\n  }\n  return null;\n}\n\nfunction createPortal(\n  children,\n  containerInfo,\n  // TODO: figure out the API for cross-renderer implementation.\n  implementation\n) {\n  var key =\n    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : \"\" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\nvar TouchHistoryMath = {\n  /**\n   * This code is optimized and not intended to look beautiful. This allows\n   * computing of touch centroids that have moved after `touchesChangedAfter`\n   * timeStamp. You can compute the current centroid involving all touches\n   * moves after `touchesChangedAfter`, or you can compute the previous\n   * centroid of all touches that were moved after `touchesChangedAfter`.\n   *\n   * @param {TouchHistoryMath} touchHistory Standard Responder touch track\n   * data.\n   * @param {number} touchesChangedAfter timeStamp after which moved touches\n   * are considered \"actively moving\" - not just \"active\".\n   * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.\n   * @param {boolean} ofCurrent Compute current centroid for actively moving\n   * touches vs. previous centroid of now actively moving touches.\n   * @return {number} value of centroid in specified dimension.\n   */\n  centroidDimension: function(\n    touchHistory,\n    touchesChangedAfter,\n    isXAxis,\n    ofCurrent\n  ) {\n    var touchBank = touchHistory.touchBank;\n    var total = 0;\n    var count = 0;\n\n    var oneTouchData =\n      touchHistory.numberActiveTouches === 1\n        ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch]\n        : null;\n\n    if (oneTouchData !== null) {\n      if (\n        oneTouchData.touchActive &&\n        oneTouchData.currentTimeStamp > touchesChangedAfter\n      ) {\n        total +=\n          ofCurrent && isXAxis\n            ? oneTouchData.currentPageX\n            : ofCurrent && !isXAxis\n              ? oneTouchData.currentPageY\n              : !ofCurrent && isXAxis\n                ? oneTouchData.previousPageX\n                : oneTouchData.previousPageY;\n        count = 1;\n      }\n    } else {\n      for (var i = 0; i < touchBank.length; i++) {\n        var touchTrack = touchBank[i];\n        if (\n          touchTrack !== null &&\n          touchTrack !== undefined &&\n          touchTrack.touchActive &&\n          touchTrack.currentTimeStamp >= touchesChangedAfter\n        ) {\n          var toAdd = void 0; // Yuck, program temporarily in invalid state.\n          if (ofCurrent && isXAxis) {\n            toAdd = touchTrack.currentPageX;\n          } else if (ofCurrent && !isXAxis) {\n            toAdd = touchTrack.currentPageY;\n          } else if (!ofCurrent && isXAxis) {\n            toAdd = touchTrack.previousPageX;\n          } else {\n            toAdd = touchTrack.previousPageY;\n          }\n          total += toAdd;\n          count++;\n        }\n      }\n    }\n    return count > 0 ? total / count : TouchHistoryMath.noCentroid;\n  },\n\n  currentCentroidXOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      true, // isXAxis\n      true\n    );\n  },\n\n  currentCentroidYOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      false, // isXAxis\n      true\n    );\n  },\n\n  previousCentroidXOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      true, // isXAxis\n      false\n    );\n  },\n\n  previousCentroidYOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      false, // isXAxis\n      false\n    );\n  },\n\n  currentCentroidX: function(touchHistory) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      0, // touchesChangedAfter\n      true, // isXAxis\n      true\n    );\n  },\n\n  currentCentroidY: function(touchHistory) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      0, // touchesChangedAfter\n      false, // isXAxis\n      true\n    );\n  },\n\n  noCentroid: -1\n};\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = \"16.3.1\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar objects = {};\nvar uniqueID = 1;\nvar emptyObject$2 = {};\n\nvar ReactNativePropRegistry = (function() {\n  function ReactNativePropRegistry() {\n    _classCallCheck(this, ReactNativePropRegistry);\n  }\n\n  ReactNativePropRegistry.register = function register(object) {\n    var id = ++uniqueID;\n    {\n      Object.freeze(object);\n    }\n    objects[id] = object;\n    return id;\n  };\n\n  ReactNativePropRegistry.getByID = function getByID(id) {\n    if (!id) {\n      // Used in the style={[condition && id]} pattern,\n      // we want it to be a no-op when the value is false or null\n      return emptyObject$2;\n    }\n\n    var object = objects[id];\n    if (!object) {\n      console.warn(\"Invalid style with id `\" + id + \"`. Skipping ...\");\n      return emptyObject$2;\n    }\n    return object;\n  };\n\n  return ReactNativePropRegistry;\n})();\n\n// Modules provided by RN:\nvar emptyObject$1 = {};\n\n/**\n * Create a payload that contains all the updates between two sets of props.\n *\n * These helpers are all encapsulated into a single module, because they use\n * mutation as a performance optimization which leads to subtle shared\n * dependencies between the code paths. To avoid this mutable state leaking\n * across modules, I've kept them isolated to this module.\n */\n\n// Tracks removed keys\nvar removedKeys = null;\nvar removedKeyCount = 0;\n\nfunction defaultDiffer(prevProp, nextProp) {\n  if (typeof nextProp !== \"object\" || nextProp === null) {\n    // Scalars have already been checked for equality\n    return true;\n  } else {\n    // For objects and arrays, the default diffing algorithm is a deep compare\n    return deepDiffer(prevProp, nextProp);\n  }\n}\n\nfunction resolveObject(idOrObject) {\n  if (typeof idOrObject === \"number\") {\n    return ReactNativePropRegistry.getByID(idOrObject);\n  }\n  return idOrObject;\n}\n\nfunction restoreDeletedValuesInNestedArray(\n  updatePayload,\n  node,\n  validAttributes\n) {\n  if (Array.isArray(node)) {\n    var i = node.length;\n    while (i-- && removedKeyCount > 0) {\n      restoreDeletedValuesInNestedArray(\n        updatePayload,\n        node[i],\n        validAttributes\n      );\n    }\n  } else if (node && removedKeyCount > 0) {\n    var obj = resolveObject(node);\n    for (var propKey in removedKeys) {\n      if (!removedKeys[propKey]) {\n        continue;\n      }\n      var _nextProp = obj[propKey];\n      if (_nextProp === undefined) {\n        continue;\n      }\n\n      var attributeConfig = validAttributes[propKey];\n      if (!attributeConfig) {\n        continue; // not a valid native prop\n      }\n\n      if (typeof _nextProp === \"function\") {\n        _nextProp = true;\n      }\n      if (typeof _nextProp === \"undefined\") {\n        _nextProp = null;\n      }\n\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = _nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(_nextProp)\n            : _nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      removedKeys[propKey] = false;\n      removedKeyCount--;\n    }\n  }\n}\n\nfunction diffNestedArrayProperty(\n  updatePayload,\n  prevArray,\n  nextArray,\n  validAttributes\n) {\n  var minLength =\n    prevArray.length < nextArray.length ? prevArray.length : nextArray.length;\n  var i = void 0;\n  for (i = 0; i < minLength; i++) {\n    // Diff any items in the array in the forward direction. Repeated keys\n    // will be overwritten by later values.\n    updatePayload = diffNestedProperty(\n      updatePayload,\n      prevArray[i],\n      nextArray[i],\n      validAttributes\n    );\n  }\n  for (; i < prevArray.length; i++) {\n    // Clear out all remaining properties.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevArray[i],\n      validAttributes\n    );\n  }\n  for (; i < nextArray.length; i++) {\n    // Add all remaining properties.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextArray[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\nfunction diffNestedProperty(\n  updatePayload,\n  prevProp,\n  nextProp,\n  validAttributes\n) {\n  if (!updatePayload && prevProp === nextProp) {\n    // If no properties have been added, then we can bail out quickly on object\n    // equality.\n    return updatePayload;\n  }\n\n  if (!prevProp || !nextProp) {\n    if (nextProp) {\n      return addNestedProperty(updatePayload, nextProp, validAttributes);\n    }\n    if (prevProp) {\n      return clearNestedProperty(updatePayload, prevProp, validAttributes);\n    }\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n    // Both are leaves, we can diff the leaves.\n    return diffProperties(\n      updatePayload,\n      resolveObject(prevProp),\n      resolveObject(nextProp),\n      validAttributes\n    );\n  }\n\n  if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n    // Both are arrays, we can diff the arrays.\n    return diffNestedArrayProperty(\n      updatePayload,\n      prevProp,\n      nextProp,\n      validAttributes\n    );\n  }\n\n  if (Array.isArray(prevProp)) {\n    return diffProperties(\n      updatePayload,\n      // $FlowFixMe - We know that this is always an object when the input is.\n      flattenStyle(prevProp),\n      // $FlowFixMe - We know that this isn't an array because of above flow.\n      resolveObject(nextProp),\n      validAttributes\n    );\n  }\n\n  return diffProperties(\n    updatePayload,\n    resolveObject(prevProp),\n    // $FlowFixMe - We know that this is always an object when the input is.\n    flattenStyle(nextProp),\n    validAttributes\n  );\n}\n\n/**\n * addNestedProperty takes a single set of props and valid attribute\n * attribute configurations. It processes each prop and adds it to the\n * updatePayload.\n */\nfunction addNestedProperty(updatePayload, nextProp, validAttributes) {\n  if (!nextProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(nextProp)) {\n    // Add each property of the leaf.\n    return addProperties(\n      updatePayload,\n      resolveObject(nextProp),\n      validAttributes\n    );\n  }\n\n  for (var i = 0; i < nextProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextProp[i],\n      validAttributes\n    );\n  }\n\n  return updatePayload;\n}\n\n/**\n * clearNestedProperty takes a single set of props and valid attributes. It\n * adds a null sentinel to the updatePayload, for each prop key.\n */\nfunction clearNestedProperty(updatePayload, prevProp, validAttributes) {\n  if (!prevProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp)) {\n    // Add each property of the leaf.\n    return clearProperties(\n      updatePayload,\n      resolveObject(prevProp),\n      validAttributes\n    );\n  }\n\n  for (var i = 0; i < prevProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevProp[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\n/**\n * diffProperties takes two sets of props and a set of valid attributes\n * and write to updatePayload the values that changed or were deleted.\n * If no updatePayload is provided, a new one is created and returned if\n * anything changed.\n */\nfunction diffProperties(updatePayload, prevProps, nextProps, validAttributes) {\n  var attributeConfig = void 0;\n  var nextProp = void 0;\n  var prevProp = void 0;\n\n  for (var propKey in nextProps) {\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    prevProp = prevProps[propKey];\n    nextProp = nextProps[propKey];\n\n    // functions are converted to booleans as markers that the associated\n    // events should be sent from native.\n    if (typeof nextProp === \"function\") {\n      nextProp = true;\n      // If nextProp is not a function, then don't bother changing prevProp\n      // since nextProp will win and go into the updatePayload regardless.\n      if (typeof prevProp === \"function\") {\n        prevProp = true;\n      }\n    }\n\n    // An explicit value of undefined is treated as a null because it overrides\n    // any other preceding value.\n    if (typeof nextProp === \"undefined\") {\n      nextProp = null;\n      if (typeof prevProp === \"undefined\") {\n        prevProp = null;\n      }\n    }\n\n    if (removedKeys) {\n      removedKeys[propKey] = false;\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // Something else already triggered an update to this key because another\n      // value diffed. Since we're now later in the nested arrays our value is\n      // more important so we need to calculate it and override the existing\n      // value. It doesn't matter if nothing changed, we'll set it anyway.\n\n      // Pattern match on: attributeConfig\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      continue;\n    }\n\n    if (prevProp === nextProp) {\n      continue; // nothing changed\n    }\n\n    // Pattern match on: attributeConfig\n    if (typeof attributeConfig !== \"object\") {\n      // case: !Object is the default case\n      if (defaultDiffer(prevProp, nextProp)) {\n        // a normal leaf has changed\n        (updatePayload || (updatePayload = {}))[propKey] = nextProp;\n      }\n    } else if (\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration\n      var shouldUpdate =\n        prevProp === undefined ||\n        (typeof attributeConfig.diff === \"function\"\n          ? attributeConfig.diff(prevProp, nextProp)\n          : defaultDiffer(prevProp, nextProp));\n      if (shouldUpdate) {\n        var _nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        (updatePayload || (updatePayload = {}))[propKey] = _nextValue;\n      }\n    } else {\n      // default: fallthrough case when nested properties are defined\n      removedKeys = null;\n      removedKeyCount = 0;\n      // We think that attributeConfig is not CustomAttributeConfiguration at\n      // this point so we assume it must be AttributeConfiguration.\n      updatePayload = diffNestedProperty(\n        updatePayload,\n        prevProp,\n        nextProp,\n        attributeConfig\n      );\n      if (removedKeyCount > 0 && updatePayload) {\n        restoreDeletedValuesInNestedArray(\n          updatePayload,\n          nextProp,\n          attributeConfig\n        );\n        removedKeys = null;\n      }\n    }\n  }\n\n  // Also iterate through all the previous props to catch any that have been\n  // removed and make sure native gets the signal so it can reset them to the\n  // default.\n  for (var _propKey in prevProps) {\n    if (nextProps[_propKey] !== undefined) {\n      continue; // we've already covered this key in the previous pass\n    }\n    attributeConfig = validAttributes[_propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    if (updatePayload && updatePayload[_propKey] !== undefined) {\n      // This was already updated to a diff result earlier.\n      continue;\n    }\n\n    prevProp = prevProps[_propKey];\n    if (prevProp === undefined) {\n      continue; // was already empty anyway\n    }\n    // Pattern match on: attributeConfig\n    if (\n      typeof attributeConfig !== \"object\" ||\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration | !Object\n      // Flag the leaf property for removal by sending a sentinel.\n      (updatePayload || (updatePayload = {}))[_propKey] = null;\n      if (!removedKeys) {\n        removedKeys = {};\n      }\n      if (!removedKeys[_propKey]) {\n        removedKeys[_propKey] = true;\n        removedKeyCount++;\n      }\n    } else {\n      // default:\n      // This is a nested attribute configuration where all the properties\n      // were removed so we need to go through and clear out all of them.\n      updatePayload = clearNestedProperty(\n        updatePayload,\n        prevProp,\n        attributeConfig\n      );\n    }\n  }\n  return updatePayload;\n}\n\n/**\n * addProperties adds all the valid props to the payload after being processed.\n */\nfunction addProperties(updatePayload, props, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(updatePayload, emptyObject$1, props, validAttributes);\n}\n\n/**\n * clearProperties clears all the previous props by adding a null sentinel\n * to the payload for each valid key.\n */\nfunction clearProperties(updatePayload, prevProps, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(\n    updatePayload,\n    prevProps,\n    emptyObject$1,\n    validAttributes\n  );\n}\n\nfunction create(props, validAttributes) {\n  return addProperties(\n    null, // updatePayload\n    props,\n    validAttributes\n  );\n}\n\nfunction diff(prevProps, nextProps, validAttributes) {\n  return diffProperties(\n    null, // updatePayload\n    prevProps,\n    nextProps,\n    validAttributes\n  );\n}\n\n/**\n * In the future, we should cleanup callbacks by cancelling them instead of\n * using this.\n */\nfunction mountSafeCallback(context, callback) {\n  return function() {\n    if (!callback) {\n      return undefined;\n    }\n    if (typeof context.__isMounted === \"boolean\") {\n      // TODO(gaearon): this is gross and should be removed.\n      // It is currently necessary because View uses createClass,\n      // and so any measure() calls on View (which are done by React\n      // DevTools) trigger the isMounted() deprecation warning.\n      if (!context.__isMounted) {\n        return undefined;\n      }\n      // The else branch is important so that we don't\n      // trigger the deprecation warning by calling isMounted.\n    } else if (typeof context.isMounted === \"function\") {\n      if (!context.isMounted()) {\n        return undefined;\n      }\n    }\n    return callback.apply(context, arguments);\n  };\n}\n\nfunction throwOnStylesProp(component, props) {\n  if (props.styles !== undefined) {\n    var owner = component._owner || null;\n    var name = component.constructor.displayName;\n    var msg =\n      \"`styles` is not a supported property of `\" +\n      name +\n      \"`, did \" +\n      \"you mean `style` (singular)?\";\n    if (owner && owner.constructor && owner.constructor.displayName) {\n      msg +=\n        \"\\n\\nCheck the `\" +\n        owner.constructor.displayName +\n        \"` parent \" +\n        \" component.\";\n    }\n    throw new Error(msg);\n  }\n}\n\nfunction warnForStyleProps(props, validAttributes) {\n  for (var key in validAttributes.style) {\n    if (!(validAttributes[key] || props[key] === undefined)) {\n      console.error(\n        \"You are setting the style `{ \" +\n          key +\n          \": ... }` as a prop. You \" +\n          \"should nest it in a style object. \" +\n          \"E.g. `{ style: { \" +\n          key +\n          \": ... } }`\"\n      );\n    }\n  }\n}\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === \"function\") {\n    return type.displayName || type.name;\n  }\n  if (typeof type === \"string\") {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return \"ReactFragment\";\n    case REACT_PORTAL_TYPE:\n      return \"ReactPortal\";\n    case REACT_CALL_TYPE:\n      return \"ReactCall\";\n    case REACT_RETURN_TYPE:\n      return \"ReactReturn\";\n  }\n  return null;\n}\n\n// TODO: Share this module between Fabric and React Native renderers\n// so that both can be used in the same tree.\n\nvar findHostInstance = function(fiber) {\n  return null;\n};\n\nvar findHostInstanceFabric = function(fiber) {\n  return null;\n};\n\nfunction injectFindHostInstance(impl) {\n  findHostInstance = impl;\n}\n\n/**\n * ReactNative vs ReactWeb\n * -----------------------\n * React treats some pieces of data opaquely. This means that the information\n * is first class (it can be passed around), but cannot be inspected. This\n * allows us to build infrastructure that reasons about resources, without\n * making assumptions about the nature of those resources, and this allows that\n * infra to be shared across multiple platforms, where the resources are very\n * different. General infra (such as `ReactMultiChild`) reasons opaquely about\n * the data, but platform specific code (such as `ReactNativeBaseComponent`) can\n * make assumptions about the data.\n *\n *\n * `rootNodeID`, uniquely identifies a position in the generated native view\n * tree. Many layers of composite components (created with `React.createClass`)\n * can all share the same `rootNodeID`.\n *\n * `nodeHandle`: A sufficiently unambiguous way to refer to a lower level\n * resource (dom node, native view etc). The `rootNodeID` is sufficient for web\n * `nodeHandle`s, because the position in a tree is always enough to uniquely\n * identify a DOM node (we never have nodes in some bank outside of the\n * document). The same would be true for `ReactNative`, but we must maintain a\n * mapping that we can send efficiently serializable\n * strings across native boundaries.\n *\n * Opaque name      TodaysWebReact   FutureWebWorkerReact   ReactNative\n * ----------------------------------------------------------------------------\n * nodeHandle       N/A              rootNodeID             tag\n */\n\n// TODO (bvaughn) Rename the findNodeHandle module to something more descriptive\n// eg findInternalHostInstance. This will reduce the likelihood of someone\n// accidentally deep-requiring this version.\nfunction findNodeHandle(componentOrHandle) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.stateNode !== null) {\n      !owner.stateNode._warnedAboutRefsInRender\n        ? warning(\n            false,\n            \"%s is accessing findNodeHandle inside its render(). \" +\n              \"render() should be a pure function of props and state. It should \" +\n              \"never access something that requires stale data from the previous \" +\n              \"render, such as refs. Move this logic to componentDidMount and \" +\n              \"componentDidUpdate instead.\",\n            getComponentName(owner) || \"A component\"\n          )\n        : void 0;\n\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrHandle == null) {\n    return null;\n  }\n  if (typeof componentOrHandle === \"number\") {\n    // Already a node handle\n    return componentOrHandle;\n  }\n\n  var component = componentOrHandle;\n\n  // TODO (balpert): Wrap iOS native components in a composite wrapper, then\n  // ReactInstanceMap.get here will always succeed for mounted components\n  var internalInstance = get(component);\n  if (internalInstance) {\n    return (\n      findHostInstance(internalInstance) ||\n      findHostInstanceFabric(internalInstance)\n    );\n  } else {\n    if (component) {\n      return component;\n    } else {\n      invariant(\n        // Native\n        (typeof component === \"object\" && \"_nativeTag\" in component) ||\n          // Composite\n          (component.render != null && typeof component.render === \"function\"),\n        \"findNodeHandle(...): Argument is not a component \" +\n          \"(type: %s, keys: %s)\",\n        typeof component,\n        Object.keys(component)\n      );\n      invariant(\n        false,\n        \"findNodeHandle(...): Unable to find node handle for unmounted \" +\n          \"component.\"\n      );\n    }\n  }\n}\n\n/**\n * External users of findNodeHandle() expect the host tag number return type.\n * The injected findNodeHandle() strategy returns the instance wrapper though.\n * See NativeMethodsMixin#setNativeProps for more info on why this is done.\n */\nfunction findNumericNodeHandleFiber(componentOrHandle) {\n  var instance = findNodeHandle(componentOrHandle);\n  if (instance == null || typeof instance === \"number\") {\n    return instance;\n  }\n  return instance._nativeTag;\n}\n\n// Modules provided by RN:\n/**\n * `NativeMethodsMixin` provides methods to access the underlying native\n * component directly. This can be useful in cases when you want to focus\n * a view or measure its on-screen dimensions, for example.\n *\n * The methods described here are available on most of the default components\n * provided by React Native. Note, however, that they are *not* available on\n * composite components that aren't directly backed by a native view. This will\n * generally include most components that you define in your own app. For more\n * information, see [Direct\n * Manipulation](docs/direct-manipulation.html).\n *\n * Note the Flow $Exact<> syntax is required to support mixins.\n * React createClass mixins can only be used with exact types.\n */\nvar NativeMethodsMixin = {\n  /**\n   * Determines the location on screen, width, and height of the given view and\n   * returns the values via an async callback. If successful, the callback will\n   * be called with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *  - pageX\n   *  - pageY\n   *\n   * Note that these measurements are not available until after the rendering\n   * has been completed in native. If you need the measurements as soon as\n   * possible, consider using the [`onLayout`\n   * prop](docs/view.html#onlayout) instead.\n   */\n  measure: function(callback) {\n    UIManager.measure(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  },\n\n  /**\n   * Determines the location of the given view in the window and returns the\n   * values via an async callback. If the React root view is embedded in\n   * another native view, this will give you the absolute coordinates. If\n   * successful, the callback will be called with the following\n   * arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *\n   * Note that these measurements are not available until after the rendering\n   * has been completed in native.\n   */\n  measureInWindow: function(callback) {\n    UIManager.measureInWindow(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  },\n\n  /**\n   * Like [`measure()`](#measure), but measures the view relative an ancestor,\n   * specified as `relativeToNativeNode`. This means that the returned x, y\n   * are relative to the origin x, y of the ancestor view.\n   *\n   * As always, to obtain a native node handle for a component, you can use\n   * `findNumericNodeHandle(component)`.\n   */\n  measureLayout: function(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      findNumericNodeHandleFiber(this),\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  },\n\n  /**\n   * This function sends props straight to native. They will not participate in\n   * future diff process - this means that if you do not include them in the\n   * next render, they will remain active (see [Direct\n   * Manipulation](docs/direct-manipulation.html)).\n   */\n  setNativeProps: function(nativeProps) {\n    // Class components don't have viewConfig -> validateAttributes.\n    // Nor does it make sense to set native props on a non-native component.\n    // Instead, find the nearest host component and set props on it.\n    // Use findNodeHandle() rather than findNumericNodeHandle() because\n    // We want the instance/wrapper (not the native tag).\n    var maybeInstance = void 0;\n\n    // Fiber errors if findNodeHandle is called for an umounted component.\n    // Tests using ReactTestRenderer will trigger this case indirectly.\n    // Mimicking stack behavior, we should silently ignore this case.\n    // TODO Fix ReactTestRenderer so we can remove this try/catch.\n    try {\n      maybeInstance = findNodeHandle(this);\n    } catch (error) {}\n\n    // If there is no host component beneath this we should fail silently.\n    // This is not an error; it could mean a class component rendered null.\n    if (maybeInstance == null) {\n      return;\n    }\n\n    var viewConfig = maybeInstance.viewConfig;\n\n    {\n      warnForStyleProps(nativeProps, viewConfig.validAttributes);\n    }\n\n    var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        maybeInstance._nativeTag,\n        viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  },\n\n  /**\n   * Requests focus for the given input or view. The exact behavior triggered\n   * will depend on the platform and type of view.\n   */\n  focus: function() {\n    TextInputState.focusTextInput(findNumericNodeHandleFiber(this));\n  },\n\n  /**\n   * Removes focus from an input or view. This is the opposite of `focus()`.\n   */\n  blur: function() {\n    TextInputState.blurTextInput(findNumericNodeHandleFiber(this));\n  }\n};\n\n{\n  // hide this from Flow since we can't define these properties outside of\n  // true without actually implementing them (setting them to undefined\n  // isn't allowed by ReactClass)\n  var NativeMethodsMixin_DEV = NativeMethodsMixin;\n  invariant(\n    !NativeMethodsMixin_DEV.componentWillMount &&\n      !NativeMethodsMixin_DEV.componentWillReceiveProps &&\n      !NativeMethodsMixin_DEV.UNSAFE_componentWillMount &&\n      !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps,\n    \"Do not override existing functions.\"\n  );\n  // TODO (bvaughn) Remove cWM and cWRP in a future version of React Native,\n  // Once these lifecycles have been remove from the reconciler.\n  NativeMethodsMixin_DEV.componentWillMount = function() {\n    throwOnStylesProp(this, this.props);\n  };\n  NativeMethodsMixin_DEV.componentWillReceiveProps = function(newProps) {\n    throwOnStylesProp(this, newProps);\n  };\n  NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function() {\n    throwOnStylesProp(this, this.props);\n  };\n  NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function(newProps) {\n    throwOnStylesProp(this, newProps);\n  };\n\n  // React may warn about cWM/cWRP/cWU methods being deprecated.\n  // Add a flag to suppress these warnings for this special case.\n  // TODO (bvaughn) Remove this flag once the above methods have been removed.\n  NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;\n  NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;\n}\n\nfunction _classCallCheck$1(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\n      \"this hasn't been initialised - super() hasn't been called\"\n    );\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\")\n    ? call\n    : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\n      \"Super expression must either be null or a function, not \" +\n        typeof superClass\n    );\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n}\n\n// Modules provided by RN:\n/**\n * Superclass that provides methods to access the underlying native component.\n * This can be useful when you want to focus a view or measure its dimensions.\n *\n * Methods implemented by this class are available on most default components\n * provided by React Native. However, they are *not* available on composite\n * components that are not directly backed by a native view. For more\n * information, see [Direct Manipulation](docs/direct-manipulation.html).\n *\n * @abstract\n */\n\nvar ReactNativeComponent = (function(_React$Component) {\n  _inherits(ReactNativeComponent, _React$Component);\n\n  function ReactNativeComponent() {\n    _classCallCheck$1(this, ReactNativeComponent);\n\n    return _possibleConstructorReturn(\n      this,\n      _React$Component.apply(this, arguments)\n    );\n  }\n\n  /**\n   * Removes focus. This is the opposite of `focus()`.\n   */\n\n  /**\n   * Due to bugs in Flow's handling of React.createClass, some fields already\n   * declared in the base class need to be redeclared below.\n   */\n  ReactNativeComponent.prototype.blur = function blur() {\n    TextInputState.blurTextInput(findNumericNodeHandleFiber(this));\n  };\n\n  /**\n   * Requests focus. The exact behavior depends on the platform and view.\n   */\n\n  ReactNativeComponent.prototype.focus = function focus() {\n    TextInputState.focusTextInput(findNumericNodeHandleFiber(this));\n  };\n\n  /**\n   * Measures the on-screen location and dimensions. If successful, the callback\n   * will be called asynchronously with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *  - pageX\n   *  - pageY\n   *\n   * These values are not available until after natives rendering completes. If\n   * you need the measurements as soon as possible, consider using the\n   * [`onLayout` prop](docs/view.html#onlayout) instead.\n   */\n\n  ReactNativeComponent.prototype.measure = function measure(callback) {\n    UIManager.measure(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  /**\n   * Measures the on-screen location and dimensions. Even if the React Native\n   * root view is embedded within another native view, this method will give you\n   * the absolute coordinates measured from the window. If successful, the\n   * callback will be called asynchronously with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *\n   * These values are not available until after natives rendering completes.\n   */\n\n  ReactNativeComponent.prototype.measureInWindow = function measureInWindow(\n    callback\n  ) {\n    UIManager.measureInWindow(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  /**\n   * Similar to [`measure()`](#measure), but the resulting location will be\n   * relative to the supplied ancestor's location.\n   *\n   * Obtain a native node handle with `ReactNative.findNodeHandle(component)`.\n   */\n\n  ReactNativeComponent.prototype.measureLayout = function measureLayout(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      findNumericNodeHandleFiber(this),\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  };\n\n  /**\n   * This function sends props straight to native. They will not participate in\n   * future diff process - this means that if you do not include them in the\n   * next render, they will remain active (see [Direct\n   * Manipulation](docs/direct-manipulation.html)).\n   */\n\n  ReactNativeComponent.prototype.setNativeProps = function setNativeProps(\n    nativeProps\n  ) {\n    // Class components don't have viewConfig -> validateAttributes.\n    // Nor does it make sense to set native props on a non-native component.\n    // Instead, find the nearest host component and set props on it.\n    // Use findNodeHandle() rather than ReactNative.findNodeHandle() because\n    // We want the instance/wrapper (not the native tag).\n    var maybeInstance = void 0;\n\n    // Fiber errors if findNodeHandle is called for an umounted component.\n    // Tests using ReactTestRenderer will trigger this case indirectly.\n    // Mimicking stack behavior, we should silently ignore this case.\n    // TODO Fix ReactTestRenderer so we can remove this try/catch.\n    try {\n      maybeInstance = findNodeHandle(this);\n    } catch (error) {}\n\n    // If there is no host component beneath this we should fail silently.\n    // This is not an error; it could mean a class component rendered null.\n    if (maybeInstance == null) {\n      return;\n    }\n\n    var viewConfig =\n      maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;\n\n    var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        maybeInstance._nativeTag,\n        viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  };\n\n  return ReactNativeComponent;\n})(React.Component);\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */ 0;\nvar PerformedWork = /*         */ 1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */ 2;\nvar Update = /*                */ 4;\nvar PlacementAndUpdate = /*    */ 6;\nvar Deletion = /*              */ 8;\nvar ContentReset = /*          */ 16;\nvar Callback = /*              */ 32;\nvar DidCapture = /*            */ 64;\nvar Ref = /*                   */ 128;\nvar ErrLog = /*                */ 256;\nvar Snapshot = /*              */ 2048;\n\n// Union of all host effects\nvar HostEffectMask = /*        */ 2559;\n\nvar Incomplete = /*            */ 512;\nvar ShouldCapture = /*         */ 1024;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node[\"return\"]) {\n      node = node[\"return\"];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node[\"return\"]) {\n      node = node[\"return\"];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      !instance._warnedAboutRefsInRender\n        ? warning(\n            false,\n            \"%s is accessing isMounted inside its render() function. \" +\n              \"render() should be a pure function of props and state. It should \" +\n              \"never access something that requires stale data from the previous \" +\n              \"render, such as refs. Move this logic to componentDidMount and \" +\n              \"componentDidUpdate instead.\",\n            getComponentName(ownerFiber) || \"A component\"\n          )\n        : void 0;\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  invariant(\n    isFiberMountedImpl(fiber) === MOUNTED,\n    \"Unable to find node on an unmounted component.\"\n  );\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    invariant(\n      state !== UNMOUNTED,\n      \"Unable to find node on an unmounted component.\"\n    );\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a[\"return\"];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, \"Unable to find node on an unmounted component.\");\n    }\n\n    if (a[\"return\"] !== b[\"return\"]) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        invariant(\n          didFindChild,\n          \"Child was not found in either parent set. This indicates a bug \" +\n            \"in React related to the return pointer. Please file an issue.\"\n        );\n      }\n    }\n\n    invariant(\n      a.alternate === b,\n      \"Return fibers should always be each others' alternates. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  invariant(\n    a.tag === HostRoot,\n    \"Unable to find node on an unmounted component.\"\n  );\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child[\"return\"] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node[\"return\"] || node[\"return\"] === currentParent) {\n        return null;\n      }\n      node = node[\"return\"];\n    }\n    node.sibling[\"return\"] = node[\"return\"];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child[\"return\"] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node[\"return\"] || node[\"return\"] === currentParent) {\n        return null;\n      }\n      node = node[\"return\"];\n    }\n    node.sibling[\"return\"] = node[\"return\"];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\n\n// TODO: Use an opaque type once ESLint et al support the syntax\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = MAX_SIGNED_31_BIT_INT;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(\n    currentTime + expirationInMs / UNIT_SIZE,\n    bucketSizeMs / UNIT_SIZE\n  );\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this[\"return\"] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function(tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode\n    );\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === \"function\") {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === \"string\") {\n    fiberTag = HostComponent;\n  } else {\n    switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(\n          pendingProps.children,\n          mode,\n          expirationTime,\n          key\n        );\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_CALL_TYPE:\n        fiberTag = CallComponent;\n        break;\n      case REACT_RETURN_TYPE:\n        fiberTag = ReturnComponent;\n        break;\n      default: {\n        if (typeof type === \"object\" && type !== null) {\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n              fiberTag = ContextProvider;\n              break;\n            case REACT_CONTEXT_TYPE:\n              // This is a consumer\n              fiberTag = ContextConsumer;\n              break;\n            case REACT_FORWARD_REF_TYPE:\n              fiberTag = ForwardRef;\n              break;\n            default:\n              if (typeof type.tag === \"number\") {\n                // Currently assumed to be a continuation and therefore is a\n                // fiber already.\n                // TODO: The yield system is currently broken for updates in\n                // some cases. The reified yield stores a fiber, but we don't\n                // know which fiber that is; the current or a workInProgress?\n                // When the continuation gets rendered here we don't know if we\n                // can reuse that fiber or if we need to clone it. There is\n                // probably a clever way to restructure this.\n                fiber = type;\n                fiber.pendingProps = pendingProps;\n                fiber.expirationTime = expirationTime;\n                return fiber;\n              } else {\n                throwOnInvalidElementType(type, owner);\n              }\n              break;\n          }\n        } else {\n          throwOnInvalidElementType(type, owner);\n        }\n      }\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction throwOnInvalidElementType(type, owner) {\n  var info = \"\";\n  {\n    if (\n      type === undefined ||\n      (typeof type === \"object\" &&\n        type !== null &&\n        Object.keys(type).length === 0)\n    ) {\n      info +=\n        \" You likely forgot to export your component from the file \" +\n        \"it's defined in, or you might have mixed up default and \" +\n        \"named imports.\";\n    }\n    var ownerName = owner ? getComponentName(owner) : null;\n    if (ownerName) {\n      info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n    }\n  }\n  invariant(\n    false,\n    \"Element type is invalid: expected a string (for built-in \" +\n      \"components) or a class/function (for composite components) \" +\n      \"but got: %s.%s\",\n    type == null ? type : typeof type,\n    info\n  );\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = \"DELETED\";\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target[\"return\"] = source[\"return\"];\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.alternate = source.alternate;\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  return target;\n}\n\n// TODO: This should be lifted into the renderer.\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    pendingCommitExpirationTime: NoWork,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    remainingExpirationTime: NoWork,\n    firstBatch: null,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function(arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, \"React DevTools encountered an error: %s\", err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(\n        false,\n        \"The installed version of React DevTools is too old and will not work \" +\n          \"with the current version of React. Please update React DevTools. \" +\n          \"https://fb.me/react-devtools\"\n      );\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function(root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function(fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, \"React DevTools encountered an error: %s.\", err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === \"function\") {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === \"function\") {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\nvar describeComponentFrame = function(name, source, ownerName) {\n  return (\n    \"\\n    in \" +\n    (name || \"Unknown\") +\n    (source\n      ? \" (at \" +\n        source.fileName.replace(/^.*[\\\\\\/]/, \"\") +\n        \":\" +\n        source.lineNumber +\n        \")\"\n      : ownerName ? \" (created by \" + ownerName + \")\" : \"\")\n  );\n};\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return \"\";\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = \"\";\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node[\"return\"];\n  } while (node);\n  return info;\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function() {};\n\n{\n  var printWarning = function(format) {\n    for (\n      var _len = arguments.length,\n        args = Array(_len > 1 ? _len - 1 : 0),\n        _key = 1;\n      _key < _len;\n      _key++\n    ) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message =\n      \"Warning: \" +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function(condition, format) {\n    if (format === undefined) {\n      throw new Error(\n        \"`warning(condition, format, ...args)` requires a warning \" +\n          \"message argument\"\n      );\n    }\n    if (!condition) {\n      for (\n        var _len2 = arguments.length,\n          args = Array(_len2 > 2 ? _len2 - 2 : 0),\n          _key2 = 2;\n        _key2 < _len2;\n        _key2++\n      ) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function() {},\n  flushPendingDeprecationWarnings: function() {},\n  flushPendingUnsafeLifecycleWarnings: function() {},\n  recordDeprecationWarnings: function(fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function(fiber, instance) {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: \"componentDidMount\",\n    UNSAFE_componentWillReceiveProps: \"static getDerivedStateFromProps\",\n    UNSAFE_componentWillUpdate: \"componentDidUpdate\"\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n\n  ReactStrictModeWarnings.discardPendingWarnings = function() {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n    pendingUnsafeLifecycleWarnings.forEach(function(\n      lifecycleWarningsMap,\n      strictRoot\n    ) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function(lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function(fiber) {\n            componentNames.add(getComponentName(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace(\"UNSAFE_\", \"\");\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = Array.from(componentNames)\n            .sort()\n            .join(\", \");\n\n          lifecyclesWarningMesages.push(\n            formatted +\n              \": Please update the following components to use \" +\n              (suggestion + \" instead: \" + sortedComponentNames)\n          );\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackAddendumByWorkInProgressFiber(\n          strictRoot\n        );\n\n        warning(\n          false,\n          \"Unsafe lifecycle methods were found within a strict-mode tree:%s\" +\n            \"\\n\\n%s\" +\n            \"\\n\\nLearn more about this warning here:\" +\n            \"\\nhttps://fb.me/react-strict-mode-warnings\",\n          strictRootComponentStack,\n          lifecyclesWarningMesages.join(\"\\n\\n\")\n        );\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var getStrictRoot = function(fiber) {\n    var maybeStrictRoot = null;\n\n    while (fiber !== null) {\n      if (fiber.mode & StrictMode) {\n        maybeStrictRoot = fiber;\n      }\n\n      fiber = fiber[\"return\"];\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function() {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function(fiber) {\n        uniqueNames.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = Array.from(uniqueNames)\n        .sort()\n        .join(\", \");\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillMount is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidMount instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillMount.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        sortedNames\n      );\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n        _uniqueNames.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = Array.from(_uniqueNames)\n        .sort()\n        .join(\", \");\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillReceiveProps is deprecated and will be removed in the next major version. \" +\n          \"Use static getDerivedStateFromProps instead.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames\n      );\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n        _uniqueNames2.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = Array.from(_uniqueNames2)\n        .sort()\n        .join(\", \");\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillUpdate is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidUpdate instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillUpdate.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames2\n      );\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function(\n    fiber,\n    instance\n  ) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (\n      typeof instance.componentWillMount === \"function\" &&\n      instance.componentWillMount.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillReceiveProps === \"function\" &&\n      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillUpdate === \"function\" &&\n      instance.componentWillUpdate.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(\n    fiber,\n    instance\n  ) {\n    var strictRoot = getStrictRoot(fiber);\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    // Note that it is sufficient to check for the presence of a\n    // single lifecycle, componentWillMount, with the polyfill flag.\n    if (\n      typeof instance.componentWillMount === \"function\" &&\n      instance.componentWillMount.__suppressDeprecationWarning === true\n    ) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (\n      typeof instance.componentWillMount === \"function\" ||\n      typeof instance.UNSAFE_componentWillMount === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillMount\");\n    }\n    if (\n      typeof instance.componentWillReceiveProps === \"function\" ||\n      typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillReceiveProps\");\n    }\n    if (\n      typeof instance.componentWillUpdate === \"function\" ||\n      typeof instance.UNSAFE_componentWillUpdate === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillUpdate\");\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function(lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n}\n\n// Re-export dynamic flags from the fbsource version.\nvar _require = require(\"ReactFeatureFlags\");\n\nvar enableGetDerivedStateFromCatch = _require.enableGetDerivedStateFromCatch;\nvar debugRenderPhaseSideEffects = _require.debugRenderPhaseSideEffects;\nvar debugRenderPhaseSideEffectsForStrictMode =\n  _require.debugRenderPhaseSideEffectsForStrictMode;\nvar warnAboutDeprecatedLifecycles = _require.warnAboutDeprecatedLifecycles;\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback =\n  _require.replayFailedUnitOfWorkWithInvokeGuardedCallback;\n\nvar enableUserTimingAPI = true;\nvar enableMutatingReconciler = true;\nvar enableNoopReconciler = false;\nvar enablePersistentReconciler = false;\n\n// Only used in www builds.\n\nfunction getCurrentFiberOwnerName() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== \"undefined\") {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n};\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = \"\\u269B\";\nvar warningEmoji = \"\\u26D4\";\nvar supportsUserTiming =\n  typeof performance !== \"undefined\" &&\n  typeof performance.mark === \"function\" &&\n  typeof performance.clearMarks === \"function\" &&\n  typeof performance.measure === \"function\" &&\n  typeof performance.clearMeasures === \"function\";\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function(markName) {\n  return reactEmoji + \" \" + markName;\n};\n\nvar formatLabel = function(label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + \" \" : reactEmoji + \" \";\n  var suffix = warning$$1 ? \" Warning: \" + warning$$1 : \"\";\n  return \"\" + prefix + label + suffix;\n};\n\nvar beginMark = function(markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function(markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function(label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function(label, debugID) {\n  return label + \" (#\" + debugID + \")\";\n};\n\nvar getFiberLabel = function(componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + \" [\" + (isMounted ? \"update\" : \"mount\") + \"]\";\n  } else {\n    // Composite component methods.\n    return componentName + \".\" + phase;\n  }\n};\n\nvar beginFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function(fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function(fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case CallComponent:\n    case ReturnComponent:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function() {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function() {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber[\"return\"];\n  }\n};\n\nvar resumeTimersRecursively = function(fiber) {\n  if (fiber[\"return\"] !== null) {\n    resumeTimersRecursively(fiber[\"return\"]);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function() {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (\n      currentPhase !== null &&\n      currentPhase !== \"componentWillMount\" &&\n      currentPhase !== \"componentWillReceiveProps\"\n    ) {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark(\"(Waiting for async callback...)\");\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire, expirationTime) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? \"React was blocked by main thread\" : null;\n      endMark(\n        \"(Waiting for async callback... will force flush in \" +\n          expirationTime +\n          \" ms)\",\n        \"(Waiting for async callback...)\",\n        warning$$1\n      );\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber[\"return\"];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber[\"return\"];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = \"An error was thrown inside this error boundary\";\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase\n        ? \"Scheduled a cascading update\"\n        : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark(\"(React Tree Reconciliation)\");\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = \"A top-level update interrupted the previous render\";\n      } else {\n        var componentName = getComponentName(interruptedBy) || \"Unknown\";\n        warning$$1 =\n          \"An update to \" + componentName + \" interrupted the previous render\";\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = \"There were cascading updates\";\n    }\n    commitCountInCurrentWorkLoop = 0;\n    var label = didCompleteRoot\n      ? \"(React Tree Reconciliation: Completed Root)\"\n      : \"(React Tree Reconciliation: Yielded)\";\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, \"(React Tree Reconciliation)\", warning$$1);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark(\"(Committing Changes)\");\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = \"Lifecycle hook scheduled a cascading update\";\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = \"Caused by a cascading update in earlier commit\";\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark(\"(Committing Changes)\", \"(Committing Changes)\", warning$$1);\n  }\n}\n\nfunction startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Snapshot Effects)\");\n  }\n}\n\nfunction stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Snapshot Effects: \" + count + \" Total)\",\n      \"(Committing Snapshot Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Host Effects)\");\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Host Effects: \" + count + \" Total)\",\n      \"(Committing Host Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Calling Lifecycle Methods)\");\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Calling Lifecycle Methods: \" + count + \" Total)\",\n      \"(Calling Lifecycle Methods)\",\n      null\n    );\n  }\n}\n\nvar didWarnUpdateInsideUpdate = void 0;\n\n{\n  didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false,\n    capturedValues: null\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (\n    queue.expirationTime === NoWork ||\n    queue.expirationTime > update.expirationTime\n  ) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nvar q1 = void 0;\nvar q2 = void 0;\nfunction ensureUpdateQueues(fiber) {\n  q1 = q2 = null;\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Use module variables instead of returning a tuple\n  q1 = queue1;\n  q2 = queue2;\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  ensureUpdateQueues(fiber);\n  var queue1 = q1;\n  var queue2 = q2;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if (\n      (queue1.isProcessing || (queue2 !== null && queue2.isProcessing)) &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      warning(\n        false,\n        \"An update (setState, replaceState, or forceUpdate) was scheduled \" +\n          \"from inside an update function. Update functions should be pure, \" +\n          \"with zero side-effects. Consider using componentDidUpdate or a \" +\n          \"callback.\"\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n    case ClassComponent:\n      var updateQueue = fiber.updateQueue;\n      if (updateQueue === null) {\n        return NoWork;\n      }\n      return updateQueue.expirationTime;\n    default:\n      return NoWork;\n  }\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === \"function\") {\n    return partialState.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(\n  current,\n  workInProgress,\n  queue,\n  instance,\n  props,\n  renderExpirationTime\n) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      capturedValues: currentQueue.capturedValues,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (\n        remainingExpirationTime === NoWork ||\n        remainingExpirationTime > updateExpirationTime\n      ) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Invoke setState callback an extra time to help detect side-effects.\n    // Ignore the return value in this case.\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      getStateFromUpdate(update, instance, state, props);\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = Object.assign({}, state, _partialState);\n        } else {\n          state = Object.assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    if (update.capturedValue !== null) {\n      var _capturedValues = queue.capturedValues;\n      if (_capturedValues === null) {\n        queue.capturedValues = [update.capturedValue];\n      } else {\n        _capturedValues.push(update.capturedValue);\n      }\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (\n    queue.first === null &&\n    !queue.hasForceUpdate &&\n    queue.capturedValues === null\n  ) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    invariant(\n      typeof _callback === \"function\",\n      \"Invalid argument passed as callback. Expected a function. Instead \" +\n        \"received: %s\",\n      _callback\n    );\n    _callback.call(context);\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\nvar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\nvar warnOnInvalidCallback = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function(callback, callerName) {\n    if (callback === null || typeof callback === \"function\") {\n      return;\n    }\n    var key = callerName + \"_\" + callback;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warning(\n        false,\n        \"%s(...): Expected the last optional `callback` argument to be a \" +\n          \"function. Instead received: %s.\",\n        callerName,\n        callback\n      );\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n    enumerable: false,\n    value: function() {\n      invariant(\n        false,\n        \"_processChildContext is not available in React 16+. This likely \" +\n          \"means you have multiple copies of React and are attempting to nest \" +\n          \"a React 15 tree inside a React 16 tree using \" +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          \"to make sure you have only one copy of React (and ideally, switch \" +\n          \"to ReactDOM.createPortal).\"\n      );\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\nfunction callGetDerivedStateFromCatch(ctor, capturedValues) {\n  var resultState = {};\n  for (var i = 0; i < capturedValues.length; i++) {\n    var capturedValue = capturedValues[i];\n    var error = capturedValue.value;\n    var partialState = ctor.getDerivedStateFromCatch.call(null, error);\n    if (partialState !== null && partialState !== undefined) {\n      Object.assign(resultState, partialState);\n    }\n  }\n  return resultState;\n}\n\nvar ReactFiberClassComponent = function(\n  legacyContext,\n  scheduleWork,\n  computeExpirationForFiber,\n  memoizeProps,\n  memoizeState\n) {\n  var cacheContext = legacyContext.cacheContext,\n    getMaskedContext = legacyContext.getMaskedContext,\n    getUnmaskedContext = legacyContext.getUnmaskedContext,\n    isContextConsumer = legacyContext.isContextConsumer,\n    hasContextChanged = legacyContext.hasContextChanged;\n\n  // Class component state updater\n\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function(instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, \"setState\");\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function(instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, \"replaceState\");\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function(instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, \"forceUpdate\");\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(\n    workInProgress,\n    oldProps,\n    newProps,\n    oldState,\n    newState,\n    newContext\n  ) {\n    if (\n      oldProps === null ||\n      (workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate)\n    ) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var ctor = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === \"function\") {\n      startPhaseTimer(workInProgress, \"shouldComponentUpdate\");\n      var shouldUpdate = instance.shouldComponentUpdate(\n        newProps,\n        newState,\n        newContext\n      );\n      stopPhaseTimer();\n\n      {\n        !(shouldUpdate !== undefined)\n          ? warning(\n              false,\n              \"%s.shouldComponentUpdate(): Returned undefined instead of a \" +\n                \"boolean value. Make sure to return true or false.\",\n              getComponentName(workInProgress) || \"Component\"\n            )\n          : void 0;\n      }\n\n      return shouldUpdate;\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n      return (\n        !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n      );\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress) || \"Component\";\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === \"function\") {\n          warning(\n            false,\n            \"%s(...): No `render` method found on the returned component \" +\n              \"instance: did you accidentally return an object from the constructor?\",\n            name\n          );\n        } else {\n          warning(\n            false,\n            \"%s(...): No `render` method found on the returned component \" +\n              \"instance: you may have forgotten to define `render`.\",\n            name\n          );\n        }\n      }\n\n      var noGetInitialStateOnES6 =\n        !instance.getInitialState ||\n        instance.getInitialState.isReactClassApproved ||\n        instance.state;\n      !noGetInitialStateOnES6\n        ? warning(\n            false,\n            \"getInitialState was defined on %s, a plain JavaScript class. \" +\n              \"This is only supported for classes created using React.createClass. \" +\n              \"Did you mean to define a state property instead?\",\n            name\n          )\n        : void 0;\n      var noGetDefaultPropsOnES6 =\n        !instance.getDefaultProps ||\n        instance.getDefaultProps.isReactClassApproved;\n      !noGetDefaultPropsOnES6\n        ? warning(\n            false,\n            \"getDefaultProps was defined on %s, a plain JavaScript class. \" +\n              \"This is only supported for classes created using React.createClass. \" +\n              \"Use a static property to define defaultProps instead.\",\n            name\n          )\n        : void 0;\n      var noInstancePropTypes = !instance.propTypes;\n      !noInstancePropTypes\n        ? warning(\n            false,\n            \"propTypes was defined as an instance property on %s. Use a static \" +\n              \"property to define propTypes instead.\",\n            name\n          )\n        : void 0;\n      var noInstanceContextTypes = !instance.contextTypes;\n      !noInstanceContextTypes\n        ? warning(\n            false,\n            \"contextTypes was defined as an instance property on %s. Use a static \" +\n              \"property to define contextTypes instead.\",\n            name\n          )\n        : void 0;\n      var noComponentShouldUpdate =\n        typeof instance.componentShouldUpdate !== \"function\";\n      !noComponentShouldUpdate\n        ? warning(\n            false,\n            \"%s has a method called \" +\n              \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" +\n              \"The name is phrased as a question because the function is \" +\n              \"expected to return a value.\",\n            name\n          )\n        : void 0;\n      if (\n        type.prototype &&\n        type.prototype.isPureReactComponent &&\n        typeof instance.shouldComponentUpdate !== \"undefined\"\n      ) {\n        warning(\n          false,\n          \"%s has a method called shouldComponentUpdate(). \" +\n            \"shouldComponentUpdate should not be used when extending React.PureComponent. \" +\n            \"Please extend React.Component if shouldComponentUpdate is used.\",\n          getComponentName(workInProgress) || \"A pure component\"\n        );\n      }\n      var noComponentDidUnmount =\n        typeof instance.componentDidUnmount !== \"function\";\n      !noComponentDidUnmount\n        ? warning(\n            false,\n            \"%s has a method called \" +\n              \"componentDidUnmount(). But there is no such lifecycle method. \" +\n              \"Did you mean componentWillUnmount()?\",\n            name\n          )\n        : void 0;\n      var noComponentDidReceiveProps =\n        typeof instance.componentDidReceiveProps !== \"function\";\n      !noComponentDidReceiveProps\n        ? warning(\n            false,\n            \"%s has a method called \" +\n              \"componentDidReceiveProps(). But there is no such lifecycle method. \" +\n              \"If you meant to update the state in response to changing props, \" +\n              \"use componentWillReceiveProps(). If you meant to fetch data or \" +\n              \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n            name\n          )\n        : void 0;\n      var noComponentWillRecieveProps =\n        typeof instance.componentWillRecieveProps !== \"function\";\n      !noComponentWillRecieveProps\n        ? warning(\n            false,\n            \"%s has a method called \" +\n              \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n            name\n          )\n        : void 0;\n      var noUnsafeComponentWillRecieveProps =\n        typeof instance.UNSAFE_componentWillRecieveProps !== \"function\";\n      !noUnsafeComponentWillRecieveProps\n        ? warning(\n            false,\n            \"%s has a method called \" +\n              \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n            name\n          )\n        : void 0;\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      !(instance.props === undefined || !hasMutatedProps)\n        ? warning(\n            false,\n            \"%s(...): When calling super() in `%s`, make sure to pass \" +\n              \"up the same props that your component's constructor was passed.\",\n            name,\n            name\n          )\n        : void 0;\n      var noInstanceDefaultProps = !instance.defaultProps;\n      !noInstanceDefaultProps\n        ? warning(\n            false,\n            \"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" +\n              \" Instead, define defaultProps as a static property on %s.\",\n            name,\n            name\n          )\n        : void 0;\n\n      if (\n        typeof instance.getSnapshotBeforeUpdate === \"function\" &&\n        typeof instance.componentDidUpdate !== \"function\" &&\n        typeof instance.componentDidUpdate !== \"function\" &&\n        !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type)\n      ) {\n        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type);\n        warning(\n          false,\n          \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" +\n            \"This component defines getSnapshotBeforeUpdate() only.\",\n          getComponentName(workInProgress)\n        );\n      }\n\n      var noInstanceGetDerivedStateFromProps =\n        typeof instance.getDerivedStateFromProps !== \"function\";\n      !noInstanceGetDerivedStateFromProps\n        ? warning(\n            false,\n            \"%s: getDerivedStateFromProps() is defined as an instance method \" +\n              \"and will be ignored. Instead, declare it as a static method.\",\n            name\n          )\n        : void 0;\n      var noInstanceGetDerivedStateFromCatch =\n        typeof instance.getDerivedStateFromCatch !== \"function\";\n      !noInstanceGetDerivedStateFromCatch\n        ? warning(\n            false,\n            \"%s: getDerivedStateFromCatch() is defined as an instance method \" +\n              \"and will be ignored. Instead, declare it as a static method.\",\n            name\n          )\n        : void 0;\n      var noStaticGetSnapshotBeforeUpdate =\n        typeof type.getSnapshotBeforeUpdate !== \"function\";\n      !noStaticGetSnapshotBeforeUpdate\n        ? warning(\n            false,\n            \"%s: getSnapshotBeforeUpdate() is defined as a static method \" +\n              \"and will be ignored. Instead, declare it as an instance method.\",\n            name\n          )\n        : void 0;\n      var _state = instance.state;\n      if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n        warning(false, \"%s.state: must be set to an object or null\", name);\n      }\n      if (typeof instance.getChildContext === \"function\") {\n        !(typeof type.childContextTypes === \"object\")\n          ? warning(\n              false,\n              \"%s.getChildContext(): childContextTypes must be defined in order to \" +\n                \"use getChildContext().\",\n              name\n            )\n          : void 0;\n      }\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext\n      ? getMaskedContext(workInProgress, unmaskedContext)\n      : emptyObject;\n\n    // Instantiate twice to help detect side-effects.\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n\n    var instance = new ctor(props, context);\n    var state =\n      instance.state !== null && instance.state !== undefined\n        ? instance.state\n        : null;\n    adoptClassInstance(workInProgress, instance);\n\n    {\n      if (\n        typeof ctor.getDerivedStateFromProps === \"function\" &&\n        state === null\n      ) {\n        var componentName = getComponentName(workInProgress) || \"Component\";\n        if (!didWarnAboutUninitializedState.has(componentName)) {\n          didWarnAboutUninitializedState.add(componentName);\n          warning(\n            false,\n            \"%s: Did not properly initialize state during construction. \" +\n              \"Expected state to be an object, but it was %s.\",\n            componentName,\n            instance.state === null ? \"null\" : \"undefined\"\n          );\n        }\n      }\n\n      // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n      // Warn about these lifecycles if they are present.\n      // Don't warn about react-lifecycles-compat polyfilled methods though.\n      if (\n        typeof ctor.getDerivedStateFromProps === \"function\" ||\n        typeof instance.getSnapshotBeforeUpdate === \"function\"\n      ) {\n        var foundWillMountName = null;\n        var foundWillReceivePropsName = null;\n        var foundWillUpdateName = null;\n        if (\n          typeof instance.componentWillMount === \"function\" &&\n          instance.componentWillMount.__suppressDeprecationWarning !== true\n        ) {\n          foundWillMountName = \"componentWillMount\";\n        } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n          foundWillMountName = \"UNSAFE_componentWillMount\";\n        }\n        if (\n          typeof instance.componentWillReceiveProps === \"function\" &&\n          instance.componentWillReceiveProps.__suppressDeprecationWarning !==\n            true\n        ) {\n          foundWillReceivePropsName = \"componentWillReceiveProps\";\n        } else if (\n          typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n        ) {\n          foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n        }\n        if (\n          typeof instance.componentWillUpdate === \"function\" &&\n          instance.componentWillUpdate.__suppressDeprecationWarning !== true\n        ) {\n          foundWillUpdateName = \"componentWillUpdate\";\n        } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n          foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n        }\n        if (\n          foundWillMountName !== null ||\n          foundWillReceivePropsName !== null ||\n          foundWillUpdateName !== null\n        ) {\n          var _componentName = getComponentName(workInProgress) || \"Component\";\n          var newApiName =\n            typeof ctor.getDerivedStateFromProps === \"function\"\n              ? \"getDerivedStateFromProps()\"\n              : \"getSnapshotBeforeUpdate()\";\n          if (\n            !didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)\n          ) {\n            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n            warning(\n              false,\n              \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" +\n                \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" +\n                \"The above lifecycles should be removed. Learn more about this warning here:\\n\" +\n                \"https://fb.me/react-async-component-lifecycle-hooks\",\n              _componentName,\n              newApiName,\n              foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\",\n              foundWillReceivePropsName !== null\n                ? \"\\n  \" + foundWillReceivePropsName\n                : \"\",\n              foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\"\n            );\n          }\n        }\n      }\n    }\n\n    workInProgress.memoizedState = state;\n\n    var partialState = callGetDerivedStateFromProps(\n      workInProgress,\n      instance,\n      props,\n      state\n    );\n\n    if (partialState !== null && partialState !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      workInProgress.memoizedState = Object.assign(\n        {},\n        workInProgress.memoizedState,\n        partialState\n      );\n    }\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    startPhaseTimer(workInProgress, \"componentWillMount\");\n    var oldState = instance.state;\n\n    if (typeof instance.componentWillMount === \"function\") {\n      instance.componentWillMount();\n    }\n    if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n      instance.UNSAFE_componentWillMount();\n    }\n\n    stopPhaseTimer();\n\n    if (oldState !== instance.state) {\n      {\n        warning(\n          false,\n          \"%s.componentWillMount(): Assigning directly to this.state is \" +\n            \"deprecated (except inside a component's \" +\n            \"constructor). Use setState instead.\",\n          getComponentName(workInProgress) || \"Component\"\n        );\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(\n    workInProgress,\n    instance,\n    newProps,\n    newContext\n  ) {\n    var oldState = instance.state;\n    startPhaseTimer(workInProgress, \"componentWillReceiveProps\");\n    if (typeof instance.componentWillReceiveProps === \"function\") {\n      instance.componentWillReceiveProps(newProps, newContext);\n    }\n    if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n      instance.UNSAFE_componentWillReceiveProps(newProps, newContext);\n    }\n    stopPhaseTimer();\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || \"Component\";\n        if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n          didWarnAboutStateAssignmentForComponent.add(componentName);\n          warning(\n            false,\n            \"%s.componentWillReceiveProps(): Assigning directly to \" +\n              \"this.state is deprecated (except inside a component's \" +\n              \"constructor). Use setState instead.\",\n            componentName\n          );\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callGetDerivedStateFromProps(\n    workInProgress,\n    instance,\n    nextProps,\n    prevState\n  ) {\n    var type = workInProgress.type;\n\n    if (typeof type.getDerivedStateFromProps === \"function\") {\n      if (\n        debugRenderPhaseSideEffects ||\n        (debugRenderPhaseSideEffectsForStrictMode &&\n          workInProgress.mode & StrictMode)\n      ) {\n        // Invoke method an extra time to help detect side-effects.\n        type.getDerivedStateFromProps.call(null, nextProps, prevState);\n      }\n\n      var partialState = type.getDerivedStateFromProps.call(\n        null,\n        nextProps,\n        prevState\n      );\n\n      {\n        if (partialState === undefined) {\n          var componentName = getComponentName(workInProgress) || \"Component\";\n          if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n            didWarnAboutUndefinedDerivedState.add(componentName);\n            warning(\n              false,\n              \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" +\n                \"You have returned undefined.\",\n              componentName\n            );\n          }\n        }\n      }\n\n      return partialState;\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    {\n      if (workInProgress.mode & StrictMode) {\n        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\n          workInProgress,\n          instance\n        );\n      }\n\n      if (warnAboutDeprecatedLifecycles) {\n        ReactStrictModeWarnings.recordDeprecationWarnings(\n          workInProgress,\n          instance\n        );\n      }\n    }\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      typeof ctor.getDerivedStateFromProps !== \"function\" &&\n      typeof instance.getSnapshotBeforeUpdate !== \"function\" &&\n      (typeof instance.UNSAFE_componentWillMount === \"function\" ||\n        typeof instance.componentWillMount === \"function\")\n    ) {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(\n          current,\n          workInProgress,\n          updateQueue,\n          instance,\n          props,\n          renderExpirationTime\n        );\n      }\n    }\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  function resumeMountClassInstance(workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    var hasNewLifecycles =\n      typeof ctor.getDerivedStateFromProps === \"function\" ||\n      typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n        typeof instance.componentWillReceiveProps === \"function\")\n    ) {\n      if (oldProps !== newProps || oldContext !== newContext) {\n        callComponentWillReceiveProps(\n          workInProgress,\n          instance,\n          newProps,\n          newContext\n        );\n      }\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    var derivedStateFromCatch = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(\n        null,\n        workInProgress,\n        workInProgress.updateQueue,\n        instance,\n        newProps,\n        renderExpirationTime\n      );\n\n      var updateQueue = workInProgress.updateQueue;\n      if (\n        updateQueue !== null &&\n        updateQueue.capturedValues !== null &&\n        enableGetDerivedStateFromCatch &&\n        typeof ctor.getDerivedStateFromCatch === \"function\"\n      ) {\n        var capturedValues = updateQueue.capturedValues;\n        // Don't remove these from the update queue yet. We need them in\n        // finishClassComponent. Do the reset there.\n        // TODO: This is awkward. Refactor class components.\n        // updateQueue.capturedValues = null;\n        derivedStateFromCatch = callGetDerivedStateFromCatch(\n          ctor,\n          capturedValues\n        );\n      }\n    } else {\n      newState = oldState;\n    }\n\n    var derivedStateFromProps = void 0;\n    if (oldProps !== newProps) {\n      // The prevState parameter should be the partially updated state.\n      // Otherwise, spreading state in return values could override updates.\n      derivedStateFromProps = callGetDerivedStateFromProps(\n        workInProgress,\n        instance,\n        newProps,\n        newState\n      );\n    }\n\n    if (derivedStateFromProps !== null && derivedStateFromProps !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState =\n        newState === null || newState === undefined\n          ? derivedStateFromProps\n          : Object.assign({}, newState, derivedStateFromProps);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue = workInProgress.updateQueue;\n      if (_updateQueue !== null) {\n        _updateQueue.baseState = Object.assign(\n          {},\n          _updateQueue.baseState,\n          derivedStateFromProps\n        );\n      }\n    }\n    if (derivedStateFromCatch !== null && derivedStateFromCatch !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState =\n        newState === null || newState === undefined\n          ? derivedStateFromCatch\n          : Object.assign({}, newState, derivedStateFromCatch);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue2 = workInProgress.updateQueue;\n      if (_updateQueue2 !== null) {\n        _updateQueue2.baseState = Object.assign(\n          {},\n          _updateQueue2.baseState,\n          derivedStateFromCatch\n        );\n      }\n    }\n\n    if (\n      oldProps === newProps &&\n      oldState === newState &&\n      !hasContextChanged() &&\n      !(\n        workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate\n      )\n    ) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidMount === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext\n    );\n\n    if (shouldUpdate) {\n      // In order to support react-lifecycles-compat polyfilled components,\n      // Unsafe lifecycles should not be invoked for components using the new APIs.\n      if (\n        !hasNewLifecycles &&\n        (typeof instance.UNSAFE_componentWillMount === \"function\" ||\n          typeof instance.componentWillMount === \"function\")\n      ) {\n        startPhaseTimer(workInProgress, \"componentWillMount\");\n        if (typeof instance.componentWillMount === \"function\") {\n          instance.componentWillMount();\n        }\n        if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n          instance.UNSAFE_componentWillMount();\n        }\n        stopPhaseTimer();\n      }\n      if (typeof instance.componentDidMount === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidMount === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    var hasNewLifecycles =\n      typeof ctor.getDerivedStateFromProps === \"function\" ||\n      typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n        typeof instance.componentWillReceiveProps === \"function\")\n    ) {\n      if (oldProps !== newProps || oldContext !== newContext) {\n        callComponentWillReceiveProps(\n          workInProgress,\n          instance,\n          newProps,\n          newContext\n        );\n      }\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    var derivedStateFromCatch = void 0;\n\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(\n        current,\n        workInProgress,\n        workInProgress.updateQueue,\n        instance,\n        newProps,\n        renderExpirationTime\n      );\n\n      var updateQueue = workInProgress.updateQueue;\n      if (\n        updateQueue !== null &&\n        updateQueue.capturedValues !== null &&\n        enableGetDerivedStateFromCatch &&\n        typeof ctor.getDerivedStateFromCatch === \"function\"\n      ) {\n        var capturedValues = updateQueue.capturedValues;\n        // Don't remove these from the update queue yet. We need them in\n        // finishClassComponent. Do the reset there.\n        // TODO: This is awkward. Refactor class components.\n        // updateQueue.capturedValues = null;\n        derivedStateFromCatch = callGetDerivedStateFromCatch(\n          ctor,\n          capturedValues\n        );\n      }\n    } else {\n      newState = oldState;\n    }\n\n    var derivedStateFromProps = void 0;\n    if (oldProps !== newProps) {\n      // The prevState parameter should be the partially updated state.\n      // Otherwise, spreading state in return values could override updates.\n      derivedStateFromProps = callGetDerivedStateFromProps(\n        workInProgress,\n        instance,\n        newProps,\n        newState\n      );\n    }\n\n    if (derivedStateFromProps !== null && derivedStateFromProps !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState =\n        newState === null || newState === undefined\n          ? derivedStateFromProps\n          : Object.assign({}, newState, derivedStateFromProps);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue3 = workInProgress.updateQueue;\n      if (_updateQueue3 !== null) {\n        _updateQueue3.baseState = Object.assign(\n          {},\n          _updateQueue3.baseState,\n          derivedStateFromProps\n        );\n      }\n    }\n    if (derivedStateFromCatch !== null && derivedStateFromCatch !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState =\n        newState === null || newState === undefined\n          ? derivedStateFromCatch\n          : Object.assign({}, newState, derivedStateFromCatch);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue4 = workInProgress.updateQueue;\n      if (_updateQueue4 !== null) {\n        _updateQueue4.baseState = Object.assign(\n          {},\n          _updateQueue4.baseState,\n          derivedStateFromCatch\n        );\n      }\n    }\n\n    if (\n      oldProps === newProps &&\n      oldState === newState &&\n      !hasContextChanged() &&\n      !(\n        workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate\n      )\n    ) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === \"function\") {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Snapshot;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext\n    );\n\n    if (shouldUpdate) {\n      // In order to support react-lifecycles-compat polyfilled components,\n      // Unsafe lifecycles should not be invoked for components using the new APIs.\n      if (\n        !hasNewLifecycles &&\n        (typeof instance.UNSAFE_componentWillUpdate === \"function\" ||\n          typeof instance.componentWillUpdate === \"function\")\n      ) {\n        startPhaseTimer(workInProgress, \"componentWillUpdate\");\n        if (typeof instance.componentWillUpdate === \"function\") {\n          instance.componentWillUpdate(newProps, newState, newContext);\n        }\n        if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n          instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);\n        }\n        stopPhaseTimer();\n      }\n      if (typeof instance.componentDidUpdate === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n      if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n        workInProgress.effectTag |= Snapshot;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === \"function\") {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Snapshot;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    callGetDerivedStateFromProps: callGetDerivedStateFromProps,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    resumeMountClassInstance: resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\nvar getCurrentFiberStackAddendum$1 =\n  ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function(child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function(child) {\n    if (child === null || typeof child !== \"object\") {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    invariant(\n      typeof child._store === \"object\",\n      \"React Component in warnForMissingKey should have a _store. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n    child._store.validated = true;\n\n    var currentComponentErrorInfo =\n      \"Each child in an array or iterator should have a unique \" +\n      '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n      \"more information.\" +\n      (getCurrentFiberStackAddendum$1() || \"\");\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(\n      false,\n      \"Each child in an array or iterator should have a unique \" +\n        '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n        \"more information.%s\",\n      getCurrentFiberStackAddendum$1()\n    );\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current, element) {\n  var mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== \"function\" &&\n    typeof mixedRef !== \"object\"\n  ) {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber) || \"Component\";\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warning(\n            false,\n            'A string ref, \"%s\",has been found within a strict mode tree. ' +\n              \"String refs are a source of potential bugs and should be avoided. \" +\n              \"We recommend using createRef() instead.\" +\n              \"\\n%s\" +\n              \"\\n\\nLearn more about using refs safely here:\" +\n              \"\\nhttps://fb.me/react-strict-mode-string-ref\",\n            mixedRef,\n            getStackAddendumByWorkInProgressFiber(returnFiber)\n          );\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        invariant(\n          ownerFiber.tag === ClassComponent,\n          \"Stateless function components cannot have refs.\"\n        );\n        inst = ownerFiber.stateNode;\n      }\n      invariant(\n        inst,\n        \"Missing owner for string ref %s. This error is likely caused by a \" +\n          \"bug in React. Please file an issue.\",\n        mixedRef\n      );\n      var stringRef = \"\" + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      var ref = function(value) {\n        var refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(\n        typeof mixedRef === \"string\",\n        \"Expected ref to be a function or a string.\"\n      );\n      invariant(\n        element._owner,\n        \"Element ref was specified as a string (%s) but no owner was set. This could happen for one of\" +\n          \" the following reasons:\\n\" +\n          \"1. You may be adding a ref to a functional component\\n\" +\n          \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n          \"3. You have multiple copies of React loaded\\n\" +\n          \"See https://fb.me/react-refs-must-have-owner for more information.\",\n        mixedRef\n      );\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== \"textarea\") {\n    var addendum = \"\";\n    {\n      addendum =\n        \" If you meant to render a collection of children, use an array \" +\n        \"instead.\" +\n        (getCurrentFiberStackAddendum$1() || \"\");\n    }\n    invariant(\n      false,\n      \"Objects are not valid as a React child (found: %s).%s\",\n      Object.prototype.toString.call(newChild) === \"[object Object]\"\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\n        : newChild,\n      addendum\n    );\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo =\n    \"Functions are not valid as a React child. This may happen if \" +\n    \"you return a Component instead of <Component /> from render. \" +\n    \"Or maybe you meant to call this function rather than return it.\" +\n    (getCurrentFiberStackAddendum$1() || \"\");\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(\n    false,\n    \"Functions are not valid as a React child. This may happen if \" +\n      \"you return a Component instead of <Component /> from render. \" +\n      \"Or maybe you meant to call this function rather than return it.%s\",\n    getCurrentFiberStackAddendum$1() || \"\"\n  );\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(\n        textContent,\n        returnFiber.mode,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current, element);\n      existing[\"return\"] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.ref = coerceRef(returnFiber, current, element);\n      created[\"return\"] = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      var created = createFiberFromPortal(\n        portal,\n        returnFiber.mode,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        expirationTime,\n        key\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText(\n        \"\" + newChild,\n        returnFiber.mode,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created.ref = coerceRef(returnFiber, null, newChild);\n          _created[\"return\"] = returnFiber;\n          return _created;\n        }\n        case REACT_PORTAL_TYPE: {\n          var _created2 = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created2[\"return\"] = returnFiber;\n          return _created2;\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          expirationTime,\n          null\n        );\n        _created3[\"return\"] = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(\n        returnFiber,\n        oldFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(\n                returnFiber,\n                oldFiber,\n                newChild.props.children,\n                expirationTime,\n                key\n              );\n            }\n            return updateElement(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(\n          returnFiber,\n          oldFiber,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    expirationTime\n  ) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(\n        returnFiber,\n        matchedFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              _matchedFiber,\n              newChild.props.children,\n              expirationTime,\n              newChild.key\n            );\n          }\n          return updateElement(\n            returnFiber,\n            _matchedFiber,\n            newChild,\n            expirationTime\n          );\n        }\n        case REACT_PORTAL_TYPE: {\n          var _matchedFiber2 =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          return updatePortal(\n            returnFiber,\n            _matchedFiber2,\n            newChild,\n            expirationTime\n          );\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(\n          returnFiber,\n          _matchedFiber3,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== \"object\" || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== \"string\") {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(\n            false,\n            \"Encountered two children with the same key, `%s`. \" +\n              \"Keys should be unique so that components maintain their identity \" +\n              \"across updates. Non-unique keys may cause children to be \" +\n              \"duplicated and/or omitted  the behavior is unsupported and \" +\n              \"could change in a future version.%s\",\n            key,\n            getCurrentFiberStackAddendum$1()\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    expirationTime\n  ) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime\n        );\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren[\"delete\"](\n              _newFiber2.key === null ? newIdx : _newFiber2.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildrenIterable,\n    expirationTime\n  ) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === \"function\",\n      \"An object is not an iterable. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === \"function\") {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          !didWarnAboutMaps\n            ? warning(\n                false,\n                \"Using Maps as children is unsupported and will likely yield \" +\n                  \"unexpected results. Convert it to a sequence/iterable of keyed \" +\n                  \"ReactElements instead.%s\",\n                getCurrentFiberStackAddendum$1()\n              )\n            : void 0;\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, \"An iterable object provided no iterator.\");\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        step.value,\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        expirationTime\n      );\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren[\"delete\"](\n              _newFiber4.key === null ? newIdx : _newFiber4.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber,\n    currentFirstChild,\n    textContent,\n    expirationTime\n  ) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(\n      textContent,\n      returnFiber.mode,\n      expirationTime\n    );\n    created[\"return\"] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber,\n    currentFirstChild,\n    element,\n    expirationTime\n  ) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === Fragment\n            ? element.type === REACT_FRAGMENT_TYPE\n            : child.type === element.type\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(\n            child,\n            element.type === REACT_FRAGMENT_TYPE\n              ? element.props.children\n              : element.props,\n            expirationTime\n          );\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing[\"return\"] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        expirationTime,\n        element.key\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4[\"return\"] = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber,\n    currentFirstChild,\n    portal,\n    expirationTime\n  ) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing[\"return\"] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(\n      portal,\n      returnFiber.mode,\n      expirationTime\n    );\n    created[\"return\"] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    expirationTime\n  ) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (\n      typeof newChild === \"object\" &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null\n    ) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === \"object\" && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n      }\n    }\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          \"\" + newChild,\n          expirationTime\n        )\n      );\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === \"undefined\") {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent: {\n          {\n            var instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent: {\n          var Component = returnFiber.type;\n          invariant(\n            false,\n            \"%s(...): Nothing was returned from render. This usually means a \" +\n              \"return statement is missing. Or, to render nothing, \" +\n              \"return null.\",\n            Component.displayName || Component.name || \"Component\"\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  invariant(\n    current === null || workInProgress.child === current.child,\n    \"Resuming work not yet implemented.\"\n  );\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(\n    currentChild,\n    currentChild.pendingProps,\n    currentChild.expirationTime\n  );\n  workInProgress.child = newChild;\n\n  newChild[\"return\"] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n      currentChild.expirationTime\n    );\n    newChild[\"return\"] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function(\n  config,\n  hostContext,\n  legacyContext,\n  newContext,\n  hydrationContext,\n  scheduleWork,\n  computeExpirationForFiber\n) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n    shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n    pushHostContainer = hostContext.pushHostContainer;\n  var pushProvider = newContext.pushProvider;\n  var getMaskedContext = legacyContext.getMaskedContext,\n    getUnmaskedContext = legacyContext.getUnmaskedContext,\n    hasLegacyContextChanged = legacyContext.hasContextChanged,\n    pushLegacyContextProvider = legacyContext.pushContextProvider,\n    pushTopLevelContextObject = legacyContext.pushTopLevelContextObject,\n    invalidateContextProvider = legacyContext.invalidateContextProvider;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n    resetHydrationState = hydrationContext.resetHydrationState,\n    tryToClaimNextHydratableInstance =\n      hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(\n      legacyContext,\n      scheduleWork,\n      computeExpirationForFiber,\n      memoizeProps,\n      memoizeState\n    ),\n    adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n    callGetDerivedStateFromProps =\n      _ReactFiberClassCompo.callGetDerivedStateFromProps,\n    constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n    mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n    resumeMountClassInstance = _ReactFiberClassCompo.resumeMountClassInstance,\n    updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(\n      current,\n      workInProgress,\n      nextChildren,\n      workInProgress.expirationTime\n    );\n  }\n\n  function reconcileChildrenAtExpirationTime(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  ) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibers(\n        workInProgress,\n        null,\n        nextChildren,\n        renderExpirationTime\n      );\n    } else {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(\n        workInProgress,\n        current.child,\n        nextChildren,\n        renderExpirationTime\n      );\n    }\n  }\n\n  function updateForwardRef(current, workInProgress) {\n    var render = workInProgress.type.render;\n    var nextChildren = render(workInProgress.pendingProps, workInProgress.ref);\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function updateMode(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps.children;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (\n      nextChildren === null ||\n      workInProgress.memoizedProps === nextChildren\n    ) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (\n      (current === null && ref !== null) ||\n      (current !== null && current.ref !== ref)\n    ) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else {\n      if (workInProgress.memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren = void 0;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushLegacyContextProvider(workInProgress);\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (workInProgress.stateNode === null) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n\n        shouldUpdate = true;\n      } else {\n        // In a resume, we'll already have an instance we can reuse.\n        shouldUpdate = resumeMountClassInstance(\n          workInProgress,\n          renderExpirationTime\n        );\n      }\n    } else {\n      shouldUpdate = updateClassInstance(\n        current,\n        workInProgress,\n        renderExpirationTime\n      );\n    }\n\n    // We processed the update queue inside updateClassInstance. It may have\n    // included some errors that were dispatched during the commit phase.\n    // TODO: Refactor class components so this is less awkward.\n    var didCaptureError = false;\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null && updateQueue.capturedValues !== null) {\n      shouldUpdate = true;\n      didCaptureError = true;\n    }\n    return finishClassComponent(\n      current,\n      workInProgress,\n      shouldUpdate,\n      hasContext,\n      didCaptureError,\n      renderExpirationTime\n    );\n  }\n\n  function finishClassComponent(\n    current,\n    workInProgress,\n    shouldUpdate,\n    hasContext,\n    didCaptureError,\n    renderExpirationTime\n  ) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate && !didCaptureError) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    if (\n      didCaptureError &&\n      (!enableGetDerivedStateFromCatch ||\n        typeof ctor.getDerivedStateFromCatch !== \"function\")\n    ) {\n      // If we captured an error, but getDerivedStateFrom catch is not defined,\n      // unmount all the children. componentDidCatch will schedule an update to\n      // re-render a fallback. This is temporary until we migrate everyone to\n      // the new API.\n      // TODO: Warn in a future release.\n      nextChildren = null;\n    } else {\n      {\n        ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n        nextChildren = instance.render();\n        if (\n          debugRenderPhaseSideEffects ||\n          (debugRenderPhaseSideEffectsForStrictMode &&\n            workInProgress.mode & StrictMode)\n        ) {\n          instance.render();\n        }\n        ReactDebugCurrentFiber.setCurrentPhase(null);\n      }\n    }\n\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    if (didCaptureError) {\n      // If we're recovering from an error, reconcile twice: first to delete\n      // all the existing children.\n      reconcileChildrenAtExpirationTime(\n        current,\n        workInProgress,\n        null,\n        renderExpirationTime\n      );\n      workInProgress.child = null;\n      // Now we can continue reconciling like normal. This has the effect of\n      // remounting all children regardless of whether their their\n      // identity matches.\n    }\n    reconcileChildrenAtExpirationTime(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime\n    );\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(\n        workInProgress,\n        root.pendingContext,\n        root.pendingContext !== root.context\n      );\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(\n        current,\n        workInProgress,\n        updateQueue,\n        null,\n        null,\n        renderExpirationTime\n      );\n      memoizeState(workInProgress, state);\n      updateQueue = workInProgress.updateQueue;\n\n      var element = void 0;\n      if (updateQueue !== null && updateQueue.capturedValues !== null) {\n        // There's an uncaught error. Unmount the whole root.\n        element = null;\n      } else if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      } else {\n        element = state.element;\n      }\n      var root = workInProgress.stateNode;\n      if (\n        (current === null || current.child === null) &&\n        root.hydrate &&\n        enterHydrationState(workInProgress)\n      ) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibers(\n          workInProgress,\n          null,\n          element,\n          renderExpirationTime\n        );\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (memoizedProps === nextProps) {\n      var isHidden =\n        workInProgress.mode & AsyncMode &&\n        shouldDeprioritizeSubtree(type, nextProps);\n      if (isHidden) {\n        // Before bailing out, make sure we've deprioritized a hidden component.\n        workInProgress.expirationTime = Never;\n      }\n      if (!isHidden || renderExpirationTime !== Never) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // If we're rendering a hidden node at hidden priority, don't bailout. The\n      // parent is complete, but the children may not be.\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (\n      renderExpirationTime !== Never &&\n      workInProgress.mode & AsyncMode &&\n      shouldDeprioritizeSubtree(type, nextProps)\n    ) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      workInProgress.memoizedProps = nextProps;\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    invariant(\n      current === null,\n      \"An indeterminate component should never have mounted. This error is \" +\n        \"likely caused by a bug in React. Please file an issue.\"\n    );\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value = void 0;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === \"function\") {\n        var componentName = getComponentName(workInProgress) || \"Unknown\";\n\n        if (!didWarnAboutBadClass[componentName]) {\n          warning(\n            false,\n            \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n              \"This is likely to cause errors. Change %s to extend React.Component instead.\",\n            componentName,\n            componentName\n          );\n          didWarnAboutBadClass[componentName] = true;\n        }\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      typeof value.render === \"function\" &&\n      value.$$typeof === undefined\n    ) {\n      var Component = workInProgress.type;\n\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      workInProgress.memoizedState =\n        value.state !== null && value.state !== undefined ? value.state : null;\n\n      if (typeof Component.getDerivedStateFromProps === \"function\") {\n        var partialState = callGetDerivedStateFromProps(\n          workInProgress,\n          value,\n          props,\n          workInProgress.memoizedState\n        );\n\n        if (partialState !== null && partialState !== undefined) {\n          workInProgress.memoizedState = Object.assign(\n            {},\n            workInProgress.memoizedState,\n            partialState\n          );\n        }\n      }\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushLegacyContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(\n        current,\n        workInProgress,\n        true,\n        hasContext,\n        false,\n        renderExpirationTime\n      );\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var _Component = workInProgress.type;\n\n        if (_Component) {\n          !!_Component.childContextTypes\n            ? warning(\n                false,\n                \"%s(...): childContextTypes cannot be defined on a functional component.\",\n                _Component.displayName || _Component.name || \"Component\"\n              )\n            : void 0;\n        }\n        if (workInProgress.ref !== null) {\n          var info = \"\";\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || \"\";\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n          }\n          if (!didWarnAboutStatelessRefs[warningKey]) {\n            didWarnAboutStatelessRefs[warningKey] = true;\n            warning(\n              false,\n              \"Stateless function components cannot be given refs. \" +\n                \"Attempts to access this ref will fail.%s%s\",\n              info,\n              ReactDebugCurrentFiber.getCurrentFiberStackAddendum()\n            );\n          }\n        }\n\n        if (typeof fn.getDerivedStateFromProps === \"function\") {\n          var _componentName = getComponentName(workInProgress) || \"Unknown\";\n\n          if (\n            !didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]\n          ) {\n            warning(\n              false,\n              \"%s: Stateless functional components do not support getDerivedStateFromProps.\",\n              _componentName\n            );\n            didWarnAboutGetDerivedStateOnFunctionalComponent[\n              _componentName\n            ] = true;\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextProps = workInProgress.pendingProps;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextProps) {\n      nextProps = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibers(\n        workInProgress,\n        workInProgress.stateNode,\n        nextChildren,\n        renderExpirationTime\n      );\n    } else {\n      workInProgress.stateNode = reconcileChildFibers(\n        workInProgress,\n        current.stateNode,\n        nextChildren,\n        renderExpirationTime\n      );\n    }\n\n    memoizeProps(workInProgress, nextProps);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibers(\n        workInProgress,\n        null,\n        nextChildren,\n        renderExpirationTime\n      );\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  function propagateContextChange(\n    workInProgress,\n    context,\n    changedBits,\n    renderExpirationTime\n  ) {\n    var fiber = workInProgress.child;\n    if (fiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      fiber[\"return\"] = workInProgress;\n    }\n    while (fiber !== null) {\n      var nextFiber = void 0;\n      // Visit this fiber.\n      switch (fiber.tag) {\n        case ContextConsumer:\n          // Check if the context matches.\n          var observedBits = fiber.stateNode | 0;\n          if (fiber.type === context && (observedBits & changedBits) !== 0) {\n            // Update the expiration time of all the ancestors, including\n            // the alternates.\n            var node = fiber;\n            while (node !== null) {\n              var alternate = node.alternate;\n              if (\n                node.expirationTime === NoWork ||\n                node.expirationTime > renderExpirationTime\n              ) {\n                node.expirationTime = renderExpirationTime;\n                if (\n                  alternate !== null &&\n                  (alternate.expirationTime === NoWork ||\n                    alternate.expirationTime > renderExpirationTime)\n                ) {\n                  alternate.expirationTime = renderExpirationTime;\n                }\n              } else if (\n                alternate !== null &&\n                (alternate.expirationTime === NoWork ||\n                  alternate.expirationTime > renderExpirationTime)\n              ) {\n                alternate.expirationTime = renderExpirationTime;\n              } else {\n                // Neither alternate was updated, which means the rest of the\n                // ancestor path already has sufficient priority.\n                break;\n              }\n              node = node[\"return\"];\n            }\n            // Don't scan deeper than a matching consumer. When we render the\n            // consumer, we'll continue scanning from that point. This way the\n            // scanning work is time-sliced.\n            nextFiber = null;\n          } else {\n            // Traverse down.\n            nextFiber = fiber.child;\n          }\n          break;\n        case ContextProvider:\n          // Don't scan deeper if this is a matching provider\n          nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n          break;\n        default:\n          // Traverse down.\n          nextFiber = fiber.child;\n          break;\n      }\n      if (nextFiber !== null) {\n        // Set the return pointer of the child to the work-in-progress fiber.\n        nextFiber[\"return\"] = fiber;\n      } else {\n        // No child. Traverse to next sibling.\n        nextFiber = fiber;\n        while (nextFiber !== null) {\n          if (nextFiber === workInProgress) {\n            // We're back to the root of this subtree. Exit.\n            nextFiber = null;\n            break;\n          }\n          var sibling = nextFiber.sibling;\n          if (sibling !== null) {\n            nextFiber = sibling;\n            break;\n          }\n          // No more siblings. Traverse up.\n          nextFiber = nextFiber[\"return\"];\n        }\n      }\n      fiber = nextFiber;\n    }\n  }\n\n  function updateContextProvider(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    var providerType = workInProgress.type;\n    var context = providerType._context;\n\n    var newProps = workInProgress.pendingProps;\n    var oldProps = workInProgress.memoizedProps;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (oldProps === newProps) {\n      workInProgress.stateNode = 0;\n      pushProvider(workInProgress);\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var newValue = newProps.value;\n    workInProgress.memoizedProps = newProps;\n\n    var changedBits = void 0;\n    if (oldProps === null) {\n      // Initial render\n      changedBits = MAX_SIGNED_31_BIT_INT;\n    } else {\n      if (oldProps.value === newProps.value) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children) {\n          workInProgress.stateNode = 0;\n          pushProvider(workInProgress);\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n        changedBits = 0;\n      } else {\n        var oldValue = oldProps.value;\n        // Use Object.is to compare the new context value to the old value.\n        // Inlined Object.is polyfill.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n        if (\n          (oldValue === newValue &&\n            (oldValue !== 0 || 1 / oldValue === 1 / newValue)) ||\n          (oldValue !== oldValue && newValue !== newValue) // eslint-disable-line no-self-compare\n        ) {\n          // No change. Bailout early if children are the same.\n          if (oldProps.children === newProps.children) {\n            workInProgress.stateNode = 0;\n            pushProvider(workInProgress);\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n          changedBits = 0;\n        } else {\n          changedBits =\n            typeof context._calculateChangedBits === \"function\"\n              ? context._calculateChangedBits(oldValue, newValue)\n              : MAX_SIGNED_31_BIT_INT;\n          {\n            !((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits)\n              ? warning(\n                  false,\n                  \"calculateChangedBits: Expected the return value to be a \" +\n                    \"31-bit integer. Instead received: %s\",\n                  changedBits\n                )\n              : void 0;\n          }\n          changedBits |= 0;\n\n          if (changedBits === 0) {\n            // No change. Bailout early if children are the same.\n            if (oldProps.children === newProps.children) {\n              workInProgress.stateNode = 0;\n              pushProvider(workInProgress);\n              return bailoutOnAlreadyFinishedWork(current, workInProgress);\n            }\n          } else {\n            propagateContextChange(\n              workInProgress,\n              context,\n              changedBits,\n              renderExpirationTime\n            );\n          }\n        }\n      }\n    }\n\n    workInProgress.stateNode = changedBits;\n    pushProvider(workInProgress);\n\n    var newChildren = newProps.children;\n    reconcileChildren(current, workInProgress, newChildren);\n    return workInProgress.child;\n  }\n\n  function updateContextConsumer(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    var context = workInProgress.type;\n    var newProps = workInProgress.pendingProps;\n    var oldProps = workInProgress.memoizedProps;\n\n    var newValue = context._currentValue;\n    var changedBits = context._changedBits;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (changedBits === 0 && oldProps === newProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    workInProgress.memoizedProps = newProps;\n\n    var observedBits = newProps.unstable_observedBits;\n    if (observedBits === undefined || observedBits === null) {\n      // Subscribe to all changes by default\n      observedBits = MAX_SIGNED_31_BIT_INT;\n    }\n    // Store the observedBits on the fiber's stateNode for quick access.\n    workInProgress.stateNode = observedBits;\n\n    if ((changedBits & observedBits) !== 0) {\n      // Context change propagation stops at matching consumers, for time-\n      // slicing. Continue the propagation here.\n      propagateContextChange(\n        workInProgress,\n        context,\n        changedBits,\n        renderExpirationTime\n      );\n    }\n    // There is no bailout on `children` equality because we expect people\n    // to often pass a bound method as a child, but it may reference\n    // `this.state` or `this.props` (and thus needs to re-render on `setState`).\n\n    var render = newProps.children;\n\n    {\n      !(typeof render === \"function\")\n        ? warning(\n            false,\n            \"A context consumer was rendered with multiple children, or a child \" +\n              \"that isn't a function. A context consumer expects a single child \" +\n              \"that is a function. If you did pass a function, make sure there \" +\n              \"is no trailing or leading whitespace around it.\"\n          )\n        : void 0;\n    }\n\n    var newChildren = render(newValue);\n    reconcileChildren(current, workInProgress, newChildren);\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushLegacyContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        );\n        break;\n      case ContextProvider:\n        pushProvider(workInProgress);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (\n      workInProgress.expirationTime === NoWork ||\n      workInProgress.expirationTime > renderExpirationTime\n    ) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case ForwardRef:\n        return updateForwardRef(current, workInProgress);\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      case Mode:\n        return updateMode(current, workInProgress);\n      case ContextProvider:\n        return updateContextProvider(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case ContextConsumer:\n        return updateContextConsumer(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      default:\n        invariant(\n          false,\n          \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n            \"React. Please file an issue.\"\n        );\n    }\n  }\n\n  return {\n    beginWork: beginWork\n  };\n};\n\nvar ReactFiberCompleteWork = function(\n  config,\n  hostContext,\n  legacyContext,\n  newContext,\n  hydrationContext\n) {\n  var createInstance = config.createInstance,\n    createTextInstance = config.createTextInstance,\n    appendInitialChild = config.appendInitialChild,\n    finalizeInitialChildren = config.finalizeInitialChildren,\n    prepareUpdate = config.prepareUpdate,\n    mutation = config.mutation,\n    persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n    popHostContext = hostContext.popHostContext,\n    getHostContext = hostContext.getHostContext,\n    popHostContainer = hostContext.popHostContainer;\n  var popLegacyContextProvider = legacyContext.popContextProvider,\n    popTopLevelLegacyContextObject = legacyContext.popTopLevelContextObject;\n  var popProvider = newContext.popProvider;\n  var prepareToHydrateHostInstance =\n      hydrationContext.prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance =\n      hydrationContext.prepareToHydrateHostTextInstance,\n    popHydrationState = hydrationContext.popHydrationState;\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node[\"return\"] = workInProgress;\n    }\n    while (node !== null) {\n      if (\n        node.tag === HostComponent ||\n        node.tag === HostText ||\n        node.tag === HostPortal\n      ) {\n        invariant(false, \"A call cannot have host component children.\");\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.pendingProps.value);\n      } else if (node.child !== null) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === workInProgress) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    var props = workInProgress.memoizedProps;\n    invariant(\n      props,\n      \"Should be resolved by now. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = props.handler;\n    var childProps = props.props;\n    var nextChildren = fn(childProps, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      currentFirstChild,\n      nextChildren,\n      renderExpirationTime\n    );\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === workInProgress) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function(workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function(\n        current,\n        workInProgress,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      ) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function(current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, \"Mutating reconciler is disabled.\");\n    }\n  } else if (persistence) {\n    if (enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n        createContainerChildSet = persistence.createContainerChildSet,\n        appendChildToContainerChildSet =\n          persistence.appendChildToContainerChildSet,\n        finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function(\n        containerChildSet,\n        workInProgress\n      ) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child[\"return\"] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node[\"return\"] === null || node[\"return\"] === workInProgress) {\n              return;\n            }\n            node = node[\"return\"];\n          }\n          node.sibling[\"return\"] = node[\"return\"];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function(workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          portalOrRoot.pendingChildren = newChildSet;\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n          finalizeContainerChildren(container, newChildSet);\n        }\n      };\n      updateHostComponent = function(\n        current,\n        workInProgress,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      ) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(\n            currentInstance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            workInProgress,\n            childrenUnchanged,\n            recyclableInstance\n          );\n          if (\n            finalizeInitialChildren(\n              newInstance,\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function(current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress\n          );\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, \"Persistent reconciler is disabled.\");\n    }\n  } else {\n    if (enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function(workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function(\n        current,\n        workInProgress,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      ) {\n        // Noop\n      };\n      updateHostText = function(current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, \"Noop reconciler is disabled.\");\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    var newProps = workInProgress.pendingProps;\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent: {\n        // We are leaving this subtree, so pop context if any.\n        popLegacyContextProvider(workInProgress);\n\n        // If this component caught an error, schedule an error log effect.\n        var instance = workInProgress.stateNode;\n        var updateQueue = workInProgress.updateQueue;\n        if (updateQueue !== null && updateQueue.capturedValues !== null) {\n          workInProgress.effectTag &= ~DidCapture;\n          if (typeof instance.componentDidCatch === \"function\") {\n            workInProgress.effectTag |= ErrLog;\n          } else {\n            // Normally we clear this in the commit phase, but since we did not\n            // schedule an effect, we need to reset it here.\n            updateQueue.capturedValues = null;\n          }\n        }\n        return null;\n      }\n      case HostRoot: {\n        popHostContainer(workInProgress);\n        popTopLevelLegacyContextObject(workInProgress);\n        var fiberRoot = workInProgress.stateNode;\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          popHydrationState(workInProgress);\n          // This resets the hacky state to fix isMounted before committing.\n          // TODO: Delete this when we delete isMounted and findDOMNode.\n          workInProgress.effectTag &= ~Placement;\n        }\n        updateHostContainer(workInProgress);\n\n        var _updateQueue = workInProgress.updateQueue;\n        if (_updateQueue !== null && _updateQueue.capturedValues !== null) {\n          workInProgress.effectTag |= ErrLog;\n        }\n        return null;\n      }\n      case HostComponent: {\n        popHostContext(workInProgress);\n        var rootContainerInstance = getRootHostContainer();\n        var type = workInProgress.type;\n        if (current !== null && workInProgress.stateNode != null) {\n          // If we have an alternate, that means this is an update and we need to\n          // schedule a side-effect to do the updates.\n          var oldProps = current.memoizedProps;\n          // If we get updated because one of our children updated, we don't\n          // have newProps so we'll have to reuse them.\n          // TODO: Split the update API as separate for the props vs. children.\n          // Even better would be if children weren't special cased at all tho.\n          var _instance = workInProgress.stateNode;\n          var currentHostContext = getHostContext();\n          // TODO: Experiencing an error where oldProps is null. Suggests a host\n          // component is hitting the resume path. Figure out why. Possibly\n          // related to `hidden`.\n          var updatePayload = prepareUpdate(\n            _instance,\n            type,\n            oldProps,\n            newProps,\n            rootContainerInstance,\n            currentHostContext\n          );\n\n          updateHostComponent(\n            current,\n            workInProgress,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            rootContainerInstance,\n            currentHostContext\n          );\n\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            invariant(\n              workInProgress.stateNode !== null,\n              \"We must have new props for new mounts. This error is likely \" +\n                \"caused by a bug in React. Please file an issue.\"\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n\n          var _currentHostContext = getHostContext();\n          // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on we want to add then top->down or\n          // bottom->up. Top->down is faster in IE11.\n          var wasHydrated = popHydrationState(workInProgress);\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (\n              prepareToHydrateHostInstance(\n                workInProgress,\n                rootContainerInstance,\n                _currentHostContext\n              )\n            ) {\n              // If changes to the hydrated node needs to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            var _instance2 = createInstance(\n              type,\n              newProps,\n              rootContainerInstance,\n              _currentHostContext,\n              workInProgress\n            );\n\n            appendAllChildren(_instance2, workInProgress);\n\n            // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n            if (\n              finalizeInitialChildren(\n                _instance2,\n                type,\n                newProps,\n                rootContainerInstance,\n                _currentHostContext\n              )\n            ) {\n              markUpdate(workInProgress);\n            }\n            workInProgress.stateNode = _instance2;\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n        return null;\n      }\n      case HostText: {\n        var newText = newProps;\n        if (current && workInProgress.stateNode != null) {\n          var oldText = current.memoizedProps;\n          // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n          updateHostText(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== \"string\") {\n            invariant(\n              workInProgress.stateNode !== null,\n              \"We must have new props for new mounts. This error is likely \" +\n                \"caused by a bug in React. Please file an issue.\"\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n          var _rootContainerInstance = getRootHostContainer();\n          var _currentHostContext2 = getHostContext();\n          var _wasHydrated = popHydrationState(workInProgress);\n          if (_wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(\n              newText,\n              _rootContainerInstance,\n              _currentHostContext2,\n              workInProgress\n            );\n          }\n        }\n        return null;\n      }\n      case CallComponent:\n        return moveCallToHandlerPhase(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case ForwardRef:\n        return null;\n      case Fragment:\n        return null;\n      case Mode:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      case ContextProvider:\n        // Pop provider fiber\n        popProvider(workInProgress);\n        return null;\n      case ContextConsumer:\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(\n          false,\n          \"An indeterminate component should have become determinate before \" +\n            \"completing. This error is likely caused by a bug in React. Please \" +\n            \"file an issue.\"\n        );\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(\n          false,\n          \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n            \"React. Please file an issue.\"\n        );\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackAddendumByWorkInProgressFiber(source)\n  };\n}\n\nvar ReactFiberUnwindWork = function(\n  hostContext,\n  legacyContext,\n  newContext,\n  scheduleWork,\n  isAlreadyFailedLegacyErrorBoundary\n) {\n  var popHostContainer = hostContext.popHostContainer,\n    popHostContext = hostContext.popHostContext;\n  var popLegacyContextProvider = legacyContext.popContextProvider,\n    popTopLevelLegacyContextObject = legacyContext.popTopLevelContextObject;\n  var popProvider = newContext.popProvider;\n\n  function throwException(returnFiber, sourceFiber, rawValue) {\n    // The source fiber did not complete.\n    sourceFiber.effectTag |= Incomplete;\n    // Its effect list is no longer valid.\n    sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n    var value = createCapturedValue(rawValue, sourceFiber);\n\n    var workInProgress = returnFiber;\n    do {\n      switch (workInProgress.tag) {\n        case HostRoot: {\n          // Uncaught error\n          var errorInfo = value;\n          ensureUpdateQueues(workInProgress);\n          var updateQueue = workInProgress.updateQueue;\n          updateQueue.capturedValues = [errorInfo];\n          workInProgress.effectTag |= ShouldCapture;\n          return;\n        }\n        case ClassComponent:\n          // Capture and retry\n          var ctor = workInProgress.type;\n          var _instance = workInProgress.stateNode;\n          if (\n            (workInProgress.effectTag & DidCapture) === NoEffect &&\n            ((typeof ctor.getDerivedStateFromCatch === \"function\" &&\n              enableGetDerivedStateFromCatch) ||\n              (_instance !== null &&\n                typeof _instance.componentDidCatch === \"function\" &&\n                !isAlreadyFailedLegacyErrorBoundary(_instance)))\n          ) {\n            ensureUpdateQueues(workInProgress);\n            var _updateQueue = workInProgress.updateQueue;\n            var capturedValues = _updateQueue.capturedValues;\n            if (capturedValues === null) {\n              _updateQueue.capturedValues = [value];\n            } else {\n              capturedValues.push(value);\n            }\n            workInProgress.effectTag |= ShouldCapture;\n            return;\n          }\n          break;\n        default:\n          break;\n      }\n      workInProgress = workInProgress[\"return\"];\n    } while (workInProgress !== null);\n  }\n\n  function unwindWork(workInProgress) {\n    switch (workInProgress.tag) {\n      case ClassComponent: {\n        popLegacyContextProvider(workInProgress);\n        var effectTag = workInProgress.effectTag;\n        if (effectTag & ShouldCapture) {\n          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n      case HostRoot: {\n        popHostContainer(workInProgress);\n        popTopLevelLegacyContextObject(workInProgress);\n        var _effectTag = workInProgress.effectTag;\n        if (_effectTag & ShouldCapture) {\n          workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n      case HostComponent: {\n        popHostContext(workInProgress);\n        return null;\n      }\n      case HostPortal:\n        popHostContainer(workInProgress);\n        return null;\n      case ContextProvider:\n        popProvider(workInProgress);\n        return null;\n      default:\n        return null;\n    }\n  }\n\n  function unwindInterruptedWork(interruptedWork) {\n    switch (interruptedWork.tag) {\n      case ClassComponent: {\n        popLegacyContextProvider(interruptedWork);\n        break;\n      }\n      case HostRoot: {\n        popHostContainer(interruptedWork);\n        popTopLevelLegacyContextObject(interruptedWork);\n        break;\n      }\n      case HostComponent: {\n        popHostContext(interruptedWork);\n        break;\n      }\n      case HostPortal:\n        popHostContainer(interruptedWork);\n        break;\n      case ContextProvider:\n        popProvider(interruptedWork);\n        break;\n      default:\n        break;\n    }\n  }\n\n  return {\n    throwException: throwException,\n    unwindWork: unwindWork,\n    unwindInterruptedWork: unwindInterruptedWork\n  };\n};\n\n// Module provided by RN:\n/**\n * Intercept lifecycle errors and ensure they are shown with the correct stack\n * trace within the native redbox component.\n */\nfunction showErrorDialog(capturedError) {\n  var componentStack = capturedError.componentStack,\n    error = capturedError.error;\n\n  var errorToHandle = void 0;\n\n  // Typically Errors are thrown but eg strings or null can be thrown as well.\n  if (error instanceof Error) {\n    var message = error.message,\n      name = error.name;\n\n    var summary = message ? name + \": \" + message : name;\n\n    errorToHandle = error;\n\n    try {\n      errorToHandle.message =\n        summary + \"\\n\\nThis error is located at:\" + componentStack;\n    } catch (e) {}\n  } else if (typeof error === \"string\") {\n    errorToHandle = new Error(\n      error + \"\\n\\nThis error is located at:\" + componentStack\n    );\n  } else {\n    errorToHandle = new Error(\"Unspecified error at:\" + componentStack);\n  }\n\n  ExceptionsManager.handleException(errorToHandle, false);\n\n  // Return false here to prevent ReactFiberErrorLogger default behavior of\n  // logging error details to console.error. Calls to console.error are\n  // automatically routed to the native redbox controller, which we've already\n  // done above by calling ExceptionsManager.\n  return false;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n      componentStack = capturedError.componentStack,\n      errorBoundaryName = capturedError.errorBoundaryName,\n      errorBoundaryFound = capturedError.errorBoundaryFound,\n      willRetry = capturedError.willRetry;\n\n    var componentNameMessage = componentName\n      ? \"The above error occurred in the <\" + componentName + \"> component:\"\n      : \"The above error occurred in one of your React components:\";\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage =\n          \"React will try to recreate this component tree from scratch \" +\n          (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n      } else {\n        errorBoundaryMessage =\n          \"This error was initially handled by the error boundary \" +\n          errorBoundaryName +\n          \".\\n\" +\n          \"Recreating the tree from scratch failed so React will unmount the tree.\";\n      }\n    } else {\n      errorBoundaryMessage =\n        \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" +\n        \"Visit https://fb.me/react-error-boundaries to learn more about error boundaries.\";\n    }\n    var combinedMessage =\n      \"\" +\n      componentNameMessage +\n      componentStack +\n      \"\\n\\n\" +\n      (\"\" + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback$3 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null) {\n    stack = getStackAddendumByWorkInProgressFiber(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source) : null,\n    componentStack: stack !== null ? stack : \"\",\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // Prevent cycle if logCapturedError() throws.\n    // A cycle may still occur if logCapturedError renders a component that throws.\n    var suppressLogging = e && e.suppressReactErrorLogging;\n    if (!suppressLogging) {\n      console.error(e);\n    }\n  }\n}\n\nvar ReactFiberCommitWork = function(\n  config,\n  captureError,\n  scheduleWork,\n  computeExpirationForFiber,\n  markLegacyErrorBoundaryAsFailed,\n  recalculateCurrentTime\n) {\n  var getPublicInstance = config.getPublicInstance,\n    mutation = config.mutation,\n    persistence = config.persistence;\n\n  var callComponentWillUnmountWithTimer = function(current, instance) {\n    startPhaseTimer(current, \"componentWillUnmount\");\n    instance.props = current.memoizedProps;\n    instance.state = current.memoizedState;\n    instance.componentWillUnmount();\n    stopPhaseTimer();\n  };\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$3(\n        null,\n        callComponentWillUnmountWithTimer,\n        null,\n        current,\n        instance\n      );\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      if (typeof ref === \"function\") {\n        {\n          invokeGuardedCallback$3(null, ref, null, null);\n          if (hasCaughtError$1()) {\n            var refError = clearCaughtError$1();\n            captureError(current, refError);\n          }\n        }\n      } else {\n        ref.current = null;\n      }\n    }\n  }\n\n  function commitBeforeMutationLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        if (finishedWork.effectTag & Snapshot) {\n          if (current !== null) {\n            var prevProps = current.memoizedProps;\n            var prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, \"getSnapshotBeforeUpdate\");\n            var _instance = finishedWork.stateNode;\n            _instance.props = finishedWork.memoizedProps;\n            _instance.state = finishedWork.memoizedState;\n            var snapshot = _instance.getSnapshotBeforeUpdate(\n              prevProps,\n              prevState\n            );\n            {\n              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n              if (\n                snapshot === undefined &&\n                !didWarnSet.has(finishedWork.type)\n              ) {\n                didWarnSet.add(finishedWork.type);\n                warning(\n                  false,\n                  \"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) \" +\n                    \"must be returned. You have returned undefined.\",\n                  getComponentName(finishedWork)\n                );\n              }\n            }\n            _instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n            stopPhaseTimer();\n          }\n        }\n        return;\n      }\n      case HostRoot:\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n        // Nothing to do for these component types\n        return;\n      default: {\n        invariant(\n          false,\n          \"This unit of work tag should not have side-effects. This error is \" +\n            \"likely caused by a bug in React. Please file an issue.\"\n        );\n      }\n    }\n  }\n\n  function commitLifeCycles(\n    finishedRoot,\n    current,\n    finishedWork,\n    currentTime,\n    committedExpirationTime\n  ) {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        var _instance2 = finishedWork.stateNode;\n        if (finishedWork.effectTag & Update) {\n          if (current === null) {\n            startPhaseTimer(finishedWork, \"componentDidMount\");\n            _instance2.props = finishedWork.memoizedProps;\n            _instance2.state = finishedWork.memoizedState;\n            _instance2.componentDidMount();\n            stopPhaseTimer();\n          } else {\n            var prevProps = current.memoizedProps;\n            var prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, \"componentDidUpdate\");\n            _instance2.props = finishedWork.memoizedProps;\n            _instance2.state = finishedWork.memoizedState;\n            _instance2.componentDidUpdate(\n              prevProps,\n              prevState,\n              _instance2.__reactInternalSnapshotBeforeUpdate\n            );\n            stopPhaseTimer();\n          }\n        }\n        var updateQueue = finishedWork.updateQueue;\n        if (updateQueue !== null) {\n          commitCallbacks(updateQueue, _instance2);\n        }\n        return;\n      }\n      case HostRoot: {\n        var _updateQueue = finishedWork.updateQueue;\n        if (_updateQueue !== null) {\n          var _instance3 = null;\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                _instance3 = getPublicInstance(finishedWork.child.stateNode);\n                break;\n              case ClassComponent:\n                _instance3 = finishedWork.child.stateNode;\n                break;\n            }\n          }\n          commitCallbacks(_updateQueue, _instance3);\n        }\n        return;\n      }\n      case HostComponent: {\n        var _instance4 = finishedWork.stateNode;\n\n        // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n        if (current === null && finishedWork.effectTag & Update) {\n          var type = finishedWork.type;\n          var props = finishedWork.memoizedProps;\n          commitMount(_instance4, type, props, finishedWork);\n        }\n\n        return;\n      }\n      case HostText: {\n        // We have no life-cycles associated with text.\n        return;\n      }\n      case HostPortal: {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          \"This unit of work tag should not have side-effects. This error is \" +\n            \"likely caused by a bug in React. Please file an issue.\"\n        );\n      }\n    }\n  }\n\n  function commitErrorLogging(finishedWork, onUncaughtError) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var ctor = finishedWork.type;\n          var _instance5 = finishedWork.stateNode;\n          var updateQueue = finishedWork.updateQueue;\n          invariant(\n            updateQueue !== null && updateQueue.capturedValues !== null,\n            \"An error logging effect should not have been scheduled if no errors \" +\n              \"were captured. This error is likely caused by a bug in React. \" +\n              \"Please file an issue.\"\n          );\n          var capturedErrors = updateQueue.capturedValues;\n          updateQueue.capturedValues = null;\n\n          if (typeof ctor.getDerivedStateFromCatch !== \"function\") {\n            // To preserve the preexisting retry behavior of error boundaries,\n            // we keep track of which ones already failed during this batch.\n            // This gets reset before we yield back to the browser.\n            // TODO: Warn in strict mode if getDerivedStateFromCatch is\n            // not defined.\n            markLegacyErrorBoundaryAsFailed(_instance5);\n          }\n\n          _instance5.props = finishedWork.memoizedProps;\n          _instance5.state = finishedWork.memoizedState;\n          for (var i = 0; i < capturedErrors.length; i++) {\n            var errorInfo = capturedErrors[i];\n            var _error = errorInfo.value;\n            var stack = errorInfo.stack;\n            logError(finishedWork, errorInfo);\n            _instance5.componentDidCatch(_error, {\n              componentStack: stack !== null ? stack : \"\"\n            });\n          }\n        }\n        break;\n      case HostRoot: {\n        var _updateQueue2 = finishedWork.updateQueue;\n        invariant(\n          _updateQueue2 !== null && _updateQueue2.capturedValues !== null,\n          \"An error logging effect should not have been scheduled if no errors \" +\n            \"were captured. This error is likely caused by a bug in React. \" +\n            \"Please file an issue.\"\n        );\n        var _capturedErrors = _updateQueue2.capturedValues;\n        _updateQueue2.capturedValues = null;\n        for (var _i = 0; _i < _capturedErrors.length; _i++) {\n          var _errorInfo = _capturedErrors[_i];\n          logError(finishedWork, _errorInfo);\n          onUncaughtError(_errorInfo.value);\n        }\n        break;\n      }\n      default:\n        invariant(\n          false,\n          \"This unit of work tag cannot capture errors.  This error is \" +\n            \"likely caused by a bug in React. Please file an issue.\"\n        );\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var _instance6 = finishedWork.stateNode;\n      var instanceToUse = void 0;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          instanceToUse = getPublicInstance(_instance6);\n          break;\n        default:\n          instanceToUse = _instance6;\n      }\n      if (typeof ref === \"function\") {\n        ref(instanceToUse);\n      } else {\n        {\n          if (!ref.hasOwnProperty(\"current\")) {\n            warning(\n              false,\n              \"Unexpected ref object provided for %s. \" +\n                \"Use either a ref-setter function or React.createRef().%s\",\n              getComponentName(finishedWork),\n              getStackAddendumByWorkInProgressFiber(finishedWork)\n            );\n          }\n        }\n\n        ref.current = instanceToUse;\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      if (typeof currentRef === \"function\") {\n        currentRef(null);\n      } else {\n        currentRef.current = null;\n      }\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === \"function\") {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent: {\n        safelyDetachRef(current);\n        var _instance7 = current.stateNode;\n        if (typeof _instance7.componentWillUnmount === \"function\") {\n          safelyCallComponentWillUnmount(current, _instance7);\n        }\n        return;\n      }\n      case HostComponent: {\n        safelyDetachRef(current);\n        return;\n      }\n      case CallComponent: {\n        commitNestedUnmounts(current.stateNode);\n        return;\n      }\n      case HostPortal: {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (enableMutatingReconciler && mutation) {\n          unmountHostComponents(current);\n        } else if (enablePersistentReconciler && persistence) {\n          emptyPortalContainer(current);\n        }\n        return;\n      }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (\n        node.child !== null &&\n        // If we use mutation we drill down into portals using commitUnmount above.\n        // If we don't use mutation we drill down into portals here instead.\n        (!mutation || node.tag !== HostPortal)\n      ) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === root) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current[\"return\"] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate[\"return\"] = null;\n    }\n  }\n\n  var emptyPortalContainer = void 0;\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n        createContainerChildSet = persistence.createContainerChildSet;\n\n      emptyPortalContainer = function(current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function(finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent: {\n            return;\n          }\n          case HostComponent: {\n            return;\n          }\n          case HostText: {\n            return;\n          }\n          case HostRoot:\n          case HostPortal: {\n            var portalOrRoot = finishedWork.stateNode;\n            var containerInfo = portalOrRoot.containerInfo,\n              _pendingChildren = portalOrRoot.pendingChildren;\n\n            replaceContainerChildren(containerInfo, _pendingChildren);\n            return;\n          }\n          default: {\n            invariant(\n              false,\n              \"This unit of work tag should not have side-effects. This error is \" +\n                \"likely caused by a bug in React. Please file an issue.\"\n            );\n          }\n        }\n      };\n    } else {\n      commitContainer = function(finishedWork) {\n        // Noop\n      };\n    }\n    if (enablePersistentReconciler || enableNoopReconciler) {\n      return {\n        commitResetTextContent: function(finishedWork) {},\n        commitPlacement: function(finishedWork) {},\n        commitDeletion: function(current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function(current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitBeforeMutationLifeCycles: commitBeforeMutationLifeCycles,\n        commitErrorLogging: commitErrorLogging,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, \"Persistent reconciler is disabled.\");\n    } else {\n      invariant(false, \"Noop reconciler is disabled.\");\n    }\n  }\n  var commitMount = mutation.commitMount,\n    commitUpdate = mutation.commitUpdate,\n    resetTextContent = mutation.resetTextContent,\n    commitTextUpdate = mutation.commitTextUpdate,\n    appendChild = mutation.appendChild,\n    appendChildToContainer = mutation.appendChildToContainer,\n    insertBefore = mutation.insertBefore,\n    insertInContainerBefore = mutation.insertInContainerBefore,\n    removeChild = mutation.removeChild,\n    removeChildFromContainer = mutation.removeChildFromContainer;\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber[\"return\"];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent[\"return\"];\n    }\n    invariant(\n      false,\n      \"Expected to find a host parent. This error is likely caused by a bug \" +\n        \"in React. Please file an issue.\"\n    );\n  }\n\n  function isHostParent(fiber) {\n    return (\n      fiber.tag === HostComponent ||\n      fiber.tag === HostRoot ||\n      fiber.tag === HostPortal\n    );\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || isHostParent(node[\"return\"])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child[\"return\"] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(\n          false,\n          \"Invalid host parent fiber. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === finishedWork) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node[\"return\"];\n        findParent: while (true) {\n          invariant(\n            parent !== null,\n            \"Expected to find a host parent. This error is likely caused by \" +\n              \"a bug in React. Please file an issue.\"\n          );\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent[\"return\"];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child[\"return\"] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child[\"return\"] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === current) {\n          return;\n        }\n        node = node[\"return\"];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        return;\n      }\n      case HostComponent: {\n        var _instance8 = finishedWork.stateNode;\n        if (_instance8 != null) {\n          // Commit the work prepared earlier.\n          var newProps = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldProps = current !== null ? current.memoizedProps : newProps;\n          var type = finishedWork.type;\n          // TODO: Type the updateQueue to be specific to host components.\n          var updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n          if (updatePayload !== null) {\n            commitUpdate(\n              _instance8,\n              updatePayload,\n              type,\n              oldProps,\n              newProps,\n              finishedWork\n            );\n          }\n        }\n        return;\n      }\n      case HostText: {\n        invariant(\n          finishedWork.stateNode !== null,\n          \"This should have a text node initialized. This error is likely \" +\n            \"caused by a bug in React. Please file an issue.\"\n        );\n        var textInstance = finishedWork.stateNode;\n        var newText = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        var oldText = current !== null ? current.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n      case HostRoot: {\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          \"This unit of work tag should not have side-effects. This error is \" +\n            \"likely caused by a bug in React. Please file an issue.\"\n        );\n      }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (enableMutatingReconciler) {\n    return {\n      commitBeforeMutationLifeCycles: commitBeforeMutationLifeCycles,\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitErrorLogging: commitErrorLogging,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, \"Mutating reconciler is disabled.\");\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function(config, stack) {\n  var getChildHostContext = config.getChildHostContext,\n    getRootHostContext = config.getRootHostContext;\n  var createCursor = stack.createCursor,\n    push = stack.push,\n    pop = stack.pop;\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    invariant(\n      c !== NO_CONTEXT,\n      \"Expected host context to exist. This error is likely caused by a bug \" +\n        \"in React. Please file an issue.\"\n    );\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n\n    // Finally, we need to push the host context to the stack.\n    // However, we can't just call getRootHostContext() and push it because\n    // we'd have a different number of entries on the stack depending on\n    // whether getRootHostContext() throws somewhere in renderer code or not.\n    // So we push an empty value first. This lets us safely unwind on errors.\n    push(contextStackCursor, NO_CONTEXT, fiber);\n    var nextRootContext = getRootHostContext(nextRootInstance);\n    // Now that we know this function doesn't throw, replace it.\n    pop(contextStackCursor, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext\n  };\n};\n\nvar ReactFiberHydrationContext = function(config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n    hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function() {\n        return false;\n      },\n      resetHydrationState: function() {},\n      tryToClaimNextHydratableInstance: function() {},\n      prepareToHydrateHostInstance: function() {\n        invariant(\n          false,\n          \"Expected prepareToHydrateHostInstance() to never be called. \" +\n            \"This error is likely caused by a bug in React. Please file an issue.\"\n        );\n      },\n      prepareToHydrateHostTextInstance: function() {\n        invariant(\n          false,\n          \"Expected prepareToHydrateHostTextInstance() to never be called. \" +\n            \"This error is likely caused by a bug in React. Please file an issue.\"\n        );\n      },\n      popHydrationState: function(fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n    canHydrateTextInstance = hydration.canHydrateTextInstance,\n    getNextHydratableSibling = hydration.getNextHydratableSibling,\n    getFirstHydratableChild = hydration.getFirstHydratableChild,\n    hydrateInstance = hydration.hydrateInstance,\n    hydrateTextInstance = hydration.hydrateTextInstance,\n    didNotMatchHydratedContainerTextInstance =\n      hydration.didNotMatchHydratedContainerTextInstance,\n    didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n    didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n    didNotHydrateInstance = hydration.didNotHydrateInstance,\n    didNotFindHydratableContainerInstance =\n      hydration.didNotFindHydratableContainerInstance,\n    didNotFindHydratableContainerTextInstance =\n      hydration.didNotFindHydratableContainerTextInstance,\n    didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n    didNotFindHydratableTextInstance =\n      hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(\n            returnFiber.stateNode.containerInfo,\n            instance\n          );\n          break;\n        case HostComponent:\n          didNotHydrateInstance(\n            returnFiber.type,\n            returnFiber.memoizedProps,\n            returnFiber.stateNode,\n            instance\n          );\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete[\"return\"] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot: {\n          var parentContainer = returnFiber.stateNode.containerInfo;\n          switch (fiber.tag) {\n            case HostComponent:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableContainerInstance(\n                parentContainer,\n                type,\n                props\n              );\n              break;\n            case HostText:\n              var text = fiber.pendingProps;\n              didNotFindHydratableContainerTextInstance(parentContainer, text);\n              break;\n          }\n          break;\n        }\n        case HostComponent: {\n          var parentType = returnFiber.type;\n          var parentProps = returnFiber.memoizedProps;\n          var parentInstance = returnFiber.stateNode;\n          switch (fiber.tag) {\n            case HostComponent:\n              var _type = fiber.type;\n              var _props = fiber.pendingProps;\n              didNotFindHydratableInstance(\n                parentType,\n                parentProps,\n                parentInstance,\n                _type,\n                _props\n              );\n              break;\n            case HostText:\n              var _text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(\n                parentType,\n                parentProps,\n                parentInstance,\n                _text\n              );\n              break;\n          }\n          break;\n        }\n        default:\n          return;\n      }\n    }\n  }\n\n  function tryHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent: {\n        var type = fiber.type;\n        var props = fiber.pendingProps;\n        var instance = canHydrateInstance(nextInstance, type, props);\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          return true;\n        }\n        return false;\n      }\n      case HostText: {\n        var text = fiber.pendingProps;\n        var textInstance = canHydrateTextInstance(nextInstance, text);\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          return true;\n        }\n        return false;\n      }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!tryHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(\n    fiber,\n    rootContainerInstance,\n    hostContext\n  ) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(\n      instance,\n      fiber.type,\n      fiber.memoizedProps,\n      rootContainerInstance,\n      hostContext,\n      fiber\n    );\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot: {\n              var parentContainer = returnFiber.stateNode.containerInfo;\n              didNotMatchHydratedContainerTextInstance(\n                parentContainer,\n                textInstance,\n                textContent\n              );\n              break;\n            }\n            case HostComponent: {\n              var parentType = returnFiber.type;\n              var parentProps = returnFiber.memoizedProps;\n              var parentInstance = returnFiber.stateNode;\n              didNotMatchHydratedTextInstance(\n                parentType,\n                parentProps,\n                parentInstance,\n                textInstance,\n                textContent\n              );\n              break;\n            }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber[\"return\"];\n    while (\n      parent !== null &&\n      parent.tag !== HostComponent &&\n      parent.tag !== HostRoot\n    ) {\n      parent = parent[\"return\"];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (\n      fiber.tag !== HostComponent ||\n      (type !== \"head\" &&\n        type !== \"body\" &&\n        !shouldSetTextContent(type, fiber.memoizedProps))\n    ) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber\n      ? getNextHydratableSibling(fiber.stateNode)\n      : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar ReactFiberLegacyContext = function(stack) {\n  var createCursor = stack.createCursor,\n    push = stack.push,\n    pop = stack.pop;\n\n  // A cursor to the current merged context object on the stack.\n\n  var contextStackCursor = createCursor(emptyObject);\n  // A cursor to a boolean indicating whether the context has changed.\n  var didPerformWorkStackCursor = createCursor(false);\n  // Keep track of the previous context object that was on the stack.\n  // We use this to get access to the parent context after we have already\n  // pushed the next context provider, and now need to merge their contexts.\n  var previousContext = emptyObject;\n\n  function getUnmaskedContext(workInProgress) {\n    var hasOwnContext = isContextProvider(workInProgress);\n    if (hasOwnContext) {\n      // If the fiber is a context provider itself, when we read its context\n      // we have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n    return contextStackCursor.current;\n  }\n\n  function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n    var instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n\n  function getMaskedContext(workInProgress, unmaskedContext) {\n    var type = workInProgress.type;\n    var contextTypes = type.contextTypes;\n    if (!contextTypes) {\n      return emptyObject;\n    }\n\n    // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n    var instance = workInProgress.stateNode;\n    if (\n      instance &&\n      instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\n    ) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    var context = {};\n    for (var key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    {\n      var name = getComponentName(workInProgress) || \"Unknown\";\n      checkPropTypes(\n        contextTypes,\n        context,\n        \"context\",\n        name,\n        ReactDebugCurrentFiber.getCurrentFiberStackAddendum\n      );\n    }\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n\n  function hasContextChanged() {\n    return didPerformWorkStackCursor.current;\n  }\n\n  function isContextConsumer(fiber) {\n    return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n  }\n\n  function isContextProvider(fiber) {\n    return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n  }\n\n  function popContextProvider(fiber) {\n    if (!isContextProvider(fiber)) {\n      return;\n    }\n\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n\n  function popTopLevelContextObject(fiber) {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n\n  function pushTopLevelContextObject(fiber, context, didChange) {\n    invariant(\n      contextStackCursor.cursor == null,\n      \"Unexpected context found on stack. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n\n  function processChildContext(fiber, parentContext) {\n    var instance = fiber.stateNode;\n    var childContextTypes = fiber.type.childContextTypes;\n\n    // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n    if (typeof instance.getChildContext !== \"function\") {\n      {\n        var componentName = getComponentName(fiber) || \"Unknown\";\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n          warning(\n            false,\n            \"%s.childContextTypes is specified but there is no getChildContext() method \" +\n              \"on the instance. You can either define getChildContext() on %s or remove \" +\n              \"childContextTypes from it.\",\n            componentName,\n            componentName\n          );\n        }\n      }\n      return parentContext;\n    }\n\n    var childContext = void 0;\n    {\n      ReactDebugCurrentFiber.setCurrentPhase(\"getChildContext\");\n    }\n    startPhaseTimer(fiber, \"getChildContext\");\n    childContext = instance.getChildContext();\n    stopPhaseTimer();\n    {\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    for (var contextKey in childContext) {\n      invariant(\n        contextKey in childContextTypes,\n        '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n        getComponentName(fiber) || \"Unknown\",\n        contextKey\n      );\n    }\n    {\n      var name = getComponentName(fiber) || \"Unknown\";\n      checkPropTypes(\n        childContextTypes,\n        childContext,\n        \"child context\",\n        name,\n        // In practice, there is one case in which we won't get a stack. It's when\n        // somebody calls unstable_renderSubtreeIntoContainer() and we process\n        // context from the parent component instance. The stack will be missing\n        // because it's outside of the reconciliation, and so the pointer has not\n        // been set. This is rare and doesn't matter. We'll also remove that API.\n        ReactDebugCurrentFiber.getCurrentFiberStackAddendum\n      );\n    }\n\n    return Object.assign({}, parentContext, childContext);\n  }\n\n  function pushContextProvider(workInProgress) {\n    if (!isContextProvider(workInProgress)) {\n      return false;\n    }\n\n    var instance = workInProgress.stateNode;\n    // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n    var memoizedMergedChildContext =\n      (instance && instance.__reactInternalMemoizedMergedChildContext) ||\n      emptyObject;\n\n    // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(\n      didPerformWorkStackCursor,\n      didPerformWorkStackCursor.current,\n      workInProgress\n    );\n\n    return true;\n  }\n\n  function invalidateContextProvider(workInProgress, didChange) {\n    var instance = workInProgress.stateNode;\n    invariant(\n      instance,\n      \"Expected to have an instance by this point. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      var mergedContext = processChildContext(workInProgress, previousContext);\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n      // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress);\n      // Now push the new context and mark that it has changed.\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n\n  function findCurrentUnmaskedContext(fiber) {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    invariant(\n      isFiberMounted(fiber) && fiber.tag === ClassComponent,\n      \"Expected subtree parent to be a mounted class component. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n\n    var node = fiber;\n    while (node.tag !== HostRoot) {\n      if (isContextProvider(node)) {\n        return node.stateNode.__reactInternalMemoizedMergedChildContext;\n      }\n      var parent = node[\"return\"];\n      invariant(\n        parent,\n        \"Found unexpected detached subtree parent. \" +\n          \"This error is likely caused by a bug in React. Please file an issue.\"\n      );\n      node = parent;\n    }\n    return node.stateNode.context;\n  }\n\n  return {\n    getUnmaskedContext: getUnmaskedContext,\n    cacheContext: cacheContext,\n    getMaskedContext: getMaskedContext,\n    hasContextChanged: hasContextChanged,\n    isContextConsumer: isContextConsumer,\n    isContextProvider: isContextProvider,\n    popContextProvider: popContextProvider,\n    popTopLevelContextObject: popTopLevelContextObject,\n    pushTopLevelContextObject: pushTopLevelContextObject,\n    processChildContext: processChildContext,\n    pushContextProvider: pushContextProvider,\n    invalidateContextProvider: invalidateContextProvider,\n    findCurrentUnmaskedContext: findCurrentUnmaskedContext\n  };\n};\n\nvar ReactFiberNewContext = function(stack) {\n  var createCursor = stack.createCursor,\n    push = stack.push,\n    pop = stack.pop;\n\n  var providerCursor = createCursor(null);\n  var valueCursor = createCursor(null);\n  var changedBitsCursor = createCursor(0);\n\n  var rendererSigil = void 0;\n  {\n    // Use this to detect multiple renderers using the same context\n    rendererSigil = {};\n  }\n\n  function pushProvider(providerFiber) {\n    var context = providerFiber.type._context;\n\n    push(changedBitsCursor, context._changedBits, providerFiber);\n    push(valueCursor, context._currentValue, providerFiber);\n    push(providerCursor, providerFiber, providerFiber);\n\n    context._currentValue = providerFiber.pendingProps.value;\n    context._changedBits = providerFiber.stateNode;\n\n    {\n      !(\n        context._currentRenderer === null ||\n        context._currentRenderer === rendererSigil\n      )\n        ? warning(\n            false,\n            \"Detected multiple renderers concurrently rendering the \" +\n              \"same context provider. This is currently unsupported.\"\n          )\n        : void 0;\n      context._currentRenderer = rendererSigil;\n    }\n  }\n\n  function popProvider(providerFiber) {\n    var changedBits = changedBitsCursor.current;\n    var currentValue = valueCursor.current;\n\n    pop(providerCursor, providerFiber);\n    pop(valueCursor, providerFiber);\n    pop(changedBitsCursor, providerFiber);\n\n    var context = providerFiber.type._context;\n    context._currentValue = currentValue;\n    context._changedBits = changedBits;\n  }\n\n  return {\n    pushProvider: pushProvider,\n    popProvider: popProvider\n  };\n};\n\nvar ReactFiberStack = function() {\n  var valueStack = [];\n\n  var fiberStack = void 0;\n\n  {\n    fiberStack = [];\n  }\n\n  var index = -1;\n\n  function createCursor(defaultValue) {\n    return {\n      current: defaultValue\n    };\n  }\n\n  function isEmpty() {\n    return index === -1;\n  }\n\n  function pop(cursor, fiber) {\n    if (index < 0) {\n      {\n        warning(false, \"Unexpected pop.\");\n      }\n      return;\n    }\n\n    {\n      if (fiber !== fiberStack[index]) {\n        warning(false, \"Unexpected Fiber popped.\");\n      }\n    }\n\n    cursor.current = valueStack[index];\n\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n\n  function push(cursor, value, fiber) {\n    index++;\n\n    valueStack[index] = cursor.current;\n\n    {\n      fiberStack[index] = fiber;\n    }\n\n    cursor.current = value;\n  }\n\n  function checkThatStackIsEmpty() {\n    {\n      if (index !== -1) {\n        warning(\n          false,\n          \"Expected an empty stack. Something was not reset properly.\"\n        );\n      }\n    }\n  }\n\n  function resetStackAfterFatalErrorInDev() {\n    {\n      index = -1;\n      valueStack.length = 0;\n      fiberStack.length = 0;\n    }\n  }\n\n  return {\n    createCursor: createCursor,\n    isEmpty: isEmpty,\n    pop: pop,\n    push: push,\n    checkThatStackIsEmpty: checkThatStackIsEmpty,\n    resetStackAfterFatalErrorInDev: resetStackAfterFatalErrorInDev\n  };\n};\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function(fiber) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    var componentName = getComponentName(fiber) || \"ReactClass\";\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(\n      false,\n      \"Can't call setState (or forceUpdate) on an unmounted component. This \" +\n        \"is a no-op, but it indicates a memory leak in your application. To \" +\n        \"fix, cancel all subscriptions and asynchronous tasks in the \" +\n        \"componentWillUnmount method.%s\",\n      getStackAddendumByWorkInProgressFiber(fiber)\n    );\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function(instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case \"getChildContext\":\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(\n          false,\n          \"setState(...): Cannot call setState() inside getChildContext()\"\n        );\n        didWarnSetStateChildContext = true;\n        break;\n      case \"render\":\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(\n          false,\n          \"Cannot update during an existing state transition (such as within \" +\n            \"`render` or another component's constructor). Render methods should \" +\n            \"be a pure function of props and state; constructor side-effects are \" +\n            \"an anti-pattern, but can be moved to `componentWillMount`.\"\n        );\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function(config) {\n  var stack = ReactFiberStack();\n  var hostContext = ReactFiberHostContext(config, stack);\n  var legacyContext = ReactFiberLegacyContext(stack);\n  var newContext = ReactFiberNewContext(stack);\n  var popHostContext = hostContext.popHostContext,\n    popHostContainer = hostContext.popHostContainer;\n  var popTopLevelLegacyContextObject = legacyContext.popTopLevelContextObject,\n    popLegacyContextProvider = legacyContext.popContextProvider;\n  var popProvider = newContext.popProvider;\n\n  var hydrationContext = ReactFiberHydrationContext(config);\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(\n      config,\n      hostContext,\n      legacyContext,\n      newContext,\n      hydrationContext,\n      scheduleWork,\n      computeExpirationForFiber\n    ),\n    beginWork = _ReactFiberBeginWork.beginWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(\n      config,\n      hostContext,\n      legacyContext,\n      newContext,\n      hydrationContext\n    ),\n    completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberUnwindWork = ReactFiberUnwindWork(\n      hostContext,\n      legacyContext,\n      newContext,\n      scheduleWork,\n      isAlreadyFailedLegacyErrorBoundary\n    ),\n    throwException = _ReactFiberUnwindWork.throwException,\n    unwindWork = _ReactFiberUnwindWork.unwindWork,\n    unwindInterruptedWork = _ReactFiberUnwindWork.unwindInterruptedWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(\n      config,\n      onCommitPhaseError,\n      scheduleWork,\n      computeExpirationForFiber,\n      markLegacyErrorBoundaryAsFailed,\n      recalculateCurrentTime\n    ),\n    commitBeforeMutationLifeCycles =\n      _ReactFiberCommitWork.commitBeforeMutationLifeCycles,\n    commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n    commitPlacement = _ReactFiberCommitWork.commitPlacement,\n    commitDeletion = _ReactFiberCommitWork.commitDeletion,\n    commitWork = _ReactFiberCommitWork.commitWork,\n    commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n    commitErrorLogging = _ReactFiberCommitWork.commitErrorLogging,\n    commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n    commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n    scheduleDeferredCallback = config.scheduleDeferredCallback,\n    cancelDeferredCallback = config.cancelDeferredCallback,\n    prepareForCommit = config.prepareForCommit,\n    resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var originalStartTimeMs = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n  var mostRecentCurrentTimeMs = originalStartTimeMs;\n\n  // Used to ensure computeUniqueAsyncExpiration is monotonically increases.\n  var lastUniqueAsyncExpiration = 0;\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  var isCommitting = false;\n\n  var isRootReadyForCommit = false;\n\n  var legacyErrorBoundariesThatAlreadyFailed = null;\n\n  // Used for performance tracking.\n  var interruptedBy = null;\n\n  var stashedWorkInProgressProperties = void 0;\n  var replayUnitOfWork = void 0;\n  var isReplayingFailedUnitOfWork = void 0;\n  var originalReplayError = void 0;\n  var rethrowOriginalError = void 0;\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = null;\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    replayUnitOfWork = function(failedUnitOfWork, error, isAsync) {\n      // Restore the original state of the work-in-progress\n      assignFiberPropertiesInDEV(\n        failedUnitOfWork,\n        stashedWorkInProgressProperties\n      );\n      switch (failedUnitOfWork.tag) {\n        case HostRoot:\n          popHostContainer(failedUnitOfWork);\n          popTopLevelLegacyContextObject(failedUnitOfWork);\n          break;\n        case HostComponent:\n          popHostContext(failedUnitOfWork);\n          break;\n        case ClassComponent:\n          popLegacyContextProvider(failedUnitOfWork);\n          break;\n        case HostPortal:\n          popHostContainer(failedUnitOfWork);\n          break;\n        case ContextProvider:\n          popProvider(failedUnitOfWork);\n          break;\n      }\n      // Replay the begin phase.\n      isReplayingFailedUnitOfWork = true;\n      originalReplayError = error;\n      invokeGuardedCallback$2(null, workLoop, null, isAsync);\n      isReplayingFailedUnitOfWork = false;\n      originalReplayError = null;\n      if (hasCaughtError()) {\n        clearCaughtError();\n      } else {\n        // If the begin phase did not fail the second time, set this pointer\n        // back to the original value.\n        nextUnitOfWork = failedUnitOfWork;\n      }\n    };\n    rethrowOriginalError = function() {\n      throw originalReplayError;\n    };\n  }\n\n  function resetStack() {\n    if (nextUnitOfWork !== null) {\n      var interruptedWork = nextUnitOfWork[\"return\"];\n      while (interruptedWork !== null) {\n        unwindInterruptedWork(interruptedWork);\n        interruptedWork = interruptedWork[\"return\"];\n      }\n    }\n\n    {\n      ReactStrictModeWarnings.discardPendingWarnings();\n      stack.checkThatStackIsEmpty();\n    }\n\n    nextRoot = null;\n    nextRenderExpirationTime = NoWork;\n    nextUnitOfWork = null;\n\n    isRootReadyForCommit = false;\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n      switch (primaryEffectTag) {\n        case Placement: {\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted\n          // does and isMounted is deprecated anyway so we should be able\n          // to kill this.\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n        case PlacementAndUpdate: {\n          // Placement\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          nextEffect.effectTag &= ~Placement;\n\n          // Update\n          var _current = nextEffect.alternate;\n          commitWork(_current, nextEffect);\n          break;\n        }\n        case Update: {\n          var _current2 = nextEffect.alternate;\n          commitWork(_current2, nextEffect);\n          break;\n        }\n        case Deletion: {\n          commitDeletion(nextEffect);\n          break;\n        }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitBeforeMutationLifecycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & Snapshot) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitBeforeMutationLifeCycles(current, nextEffect);\n      }\n\n      // Don't cleanup effects yet;\n      // This will be done by commitAllLifeCycles()\n      nextEffect = nextEffect.nextEffect;\n    }\n  }\n\n  function commitAllLifeCycles(\n    finishedRoot,\n    currentTime,\n    committedExpirationTime\n  ) {\n    {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n      if (warnAboutDeprecatedLifecycles) {\n        ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n      }\n    }\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitLifeCycles(\n          finishedRoot,\n          current,\n          nextEffect,\n          currentTime,\n          committedExpirationTime\n        );\n      }\n\n      if (effectTag & ErrLog) {\n        commitErrorLogging(nextEffect, onUncaughtError);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function isAlreadyFailedLegacyErrorBoundary(instance) {\n    return (\n      legacyErrorBoundariesThatAlreadyFailed !== null &&\n      legacyErrorBoundariesThatAlreadyFailed.has(instance)\n    );\n  }\n\n  function markLegacyErrorBoundaryAsFailed(instance) {\n    if (legacyErrorBoundariesThatAlreadyFailed === null) {\n      legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n    } else {\n      legacyErrorBoundariesThatAlreadyFailed.add(instance);\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n\n    var root = finishedWork.stateNode;\n    invariant(\n      root.current !== finishedWork,\n      \"Cannot commit the same tree as before. This is probably a bug \" +\n        \"related to the return field. This error is likely caused by a bug \" +\n        \"in React. Please file an issue.\"\n    );\n    var committedExpirationTime = root.pendingCommitExpirationTime;\n    invariant(\n      committedExpirationTime !== NoWork,\n      \"Cannot commit an incomplete root. This error is likely caused by a \" +\n        \"bug in React. Please file an issue.\"\n    );\n    root.pendingCommitExpirationTime = NoWork;\n\n    var currentTime = recalculateCurrentTime();\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit(root.containerInfo);\n\n    // Invoke instances of getSnapshotBeforeUpdate before mutation.\n    nextEffect = firstEffect;\n    startCommitSnapshotEffectsTimer();\n    while (nextEffect !== null) {\n      var didError = false;\n      var error = void 0;\n      {\n        invokeGuardedCallback$2(null, commitBeforeMutationLifecycles, null);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        invariant(\n          nextEffect !== null,\n          \"Should have next effect. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n        onCommitPhaseError(nextEffect, error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitSnapshotEffectsTimer();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback$2(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        invariant(\n          nextEffect !== null,\n          \"Should have next effect. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n        onCommitPhaseError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      var _didError2 = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback$2(\n          null,\n          commitAllLifeCycles,\n          null,\n          root,\n          currentTime,\n          committedExpirationTime\n        );\n        if (hasCaughtError()) {\n          _didError2 = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError2) {\n        invariant(\n          nextEffect !== null,\n          \"Should have next effect. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n        onCommitPhaseError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    if (typeof onCommitRoot === \"function\") {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    var remainingTime = root.current.expirationTime;\n    if (remainingTime === NoWork) {\n      // If there's no remaining work, we can clear the set of already failed\n      // error boundaries.\n      legacyErrorBoundariesThatAlreadyFailed = null;\n    }\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (\n        child.expirationTime !== NoWork &&\n        (newExpirationTime === NoWork ||\n          newExpirationTime > child.expirationTime)\n      ) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    // Attempt to complete the current unit of work, then move to the\n    // next sibling. If there are no more siblings, return to the\n    // parent fiber.\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n\n      var returnFiber = workInProgress[\"return\"];\n      var siblingFiber = workInProgress.sibling;\n\n      if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n        // This fiber completed.\n        var next = completeWork(\n          current,\n          workInProgress,\n          nextRenderExpirationTime\n        );\n        stopWorkTimer(workInProgress);\n        resetExpirationTime(workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (next !== null) {\n          stopWorkTimer(workInProgress);\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(\n              workInProgress\n            );\n          }\n          // If completing this work spawned new work, do that next. We'll come\n          // back here again.\n          return next;\n        }\n\n        if (\n          returnFiber !== null &&\n          // Do not append effects to parents if a sibling failed to complete\n          (returnFiber.effectTag & Incomplete) === NoEffect\n        ) {\n          // Append all the effects of the subtree and this fiber onto the effect\n          // list of the parent. The completion order of the children affects the\n          // side-effect order.\n          if (returnFiber.firstEffect === null) {\n            returnFiber.firstEffect = workInProgress.firstEffect;\n          }\n          if (workInProgress.lastEffect !== null) {\n            if (returnFiber.lastEffect !== null) {\n              returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n            }\n            returnFiber.lastEffect = workInProgress.lastEffect;\n          }\n\n          // If this fiber had side-effects, we append it AFTER the children's\n          // side-effects. We can perform certain side-effects earlier if\n          // needed, by doing multiple passes over the effect list. We don't want\n          // to schedule our own side-effect on our own list because if end up\n          // reusing children we'll schedule this effect onto itself since we're\n          // at the end.\n          var effectTag = workInProgress.effectTag;\n          // Skip both NoWork and PerformedWork tags when creating the effect list.\n          // PerformedWork effect is read by React DevTools but shouldn't be committed.\n          if (effectTag > PerformedWork) {\n            if (returnFiber.lastEffect !== null) {\n              returnFiber.lastEffect.nextEffect = workInProgress;\n            } else {\n              returnFiber.firstEffect = workInProgress;\n            }\n            returnFiber.lastEffect = workInProgress;\n          }\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (siblingFiber !== null) {\n          // If there is more work to do in this returnFiber, do that next.\n          return siblingFiber;\n        } else if (returnFiber !== null) {\n          // If there's no more work in this returnFiber. Complete the returnFiber.\n          workInProgress = returnFiber;\n          continue;\n        } else {\n          // We've reached the root.\n          isRootReadyForCommit = true;\n          return null;\n        }\n      } else {\n        // This fiber did not complete because something threw. Pop values off\n        // the stack without entering the complete phase. If this is a boundary,\n        // capture values if possible.\n        var _next = unwindWork(workInProgress);\n        // Because this fiber did not complete, don't reset its expiration time.\n        if (workInProgress.effectTag & DidCapture) {\n          // Restarting an error boundary\n          stopFailedWorkTimer(workInProgress);\n        } else {\n          stopWorkTimer(workInProgress);\n        }\n\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (_next !== null) {\n          stopWorkTimer(workInProgress);\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(\n              workInProgress\n            );\n          }\n          // If completing this work spawned new work, do that next. We'll come\n          // back here again.\n          // Since we're restarting, remove anything that is not a host effect\n          // from the effect tag.\n          _next.effectTag &= HostEffectMask;\n          return _next;\n        }\n\n        if (returnFiber !== null) {\n          // Mark the parent fiber as incomplete and clear its effect list.\n          returnFiber.firstEffect = returnFiber.lastEffect = null;\n          returnFiber.effectTag |= Incomplete;\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (siblingFiber !== null) {\n          // If there is more work to do in this returnFiber, do that next.\n          return siblingFiber;\n        } else if (returnFiber !== null) {\n          // If there's no more work in this returnFiber. Complete the returnFiber.\n          workInProgress = returnFiber;\n          continue;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n      stashedWorkInProgressProperties = assignFiberPropertiesInDEV(\n        stashedWorkInProgressProperties,\n        workInProgress\n      );\n    }\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n      if (isReplayingFailedUnitOfWork) {\n        // Currently replaying a failed unit of work. This should be unreachable,\n        // because the render phase is meant to be idempotent, and it should\n        // have thrown again. Since it didn't, rethrow the original error, so\n        // React's internal stack is not misaligned.\n        rethrowOriginalError();\n      }\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(isAsync) {\n    if (!isAsync) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function renderRoot(root, expirationTime, isAsync) {\n    invariant(\n      !isWorking,\n      \"renderRoot was called recursively. This error is likely caused \" +\n        \"by a bug in React. Please file an issue.\"\n    );\n    isWorking = true;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (\n      expirationTime !== nextRenderExpirationTime ||\n      root !== nextRoot ||\n      nextUnitOfWork === null\n    ) {\n      // Reset the stack and start working from the root.\n      resetStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(\n        nextRoot.current,\n        null,\n        nextRenderExpirationTime\n      );\n      root.pendingCommitExpirationTime = NoWork;\n    }\n\n    var didFatal = false;\n\n    startWorkLoopTimer(nextUnitOfWork);\n\n    do {\n      try {\n        workLoop(isAsync);\n      } catch (thrownValue) {\n        if (nextUnitOfWork === null) {\n          // This is a fatal error.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          var failedUnitOfWork = nextUnitOfWork;\n          replayUnitOfWork(failedUnitOfWork, thrownValue, isAsync);\n        }\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber[\"return\"];\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n        throwException(returnFiber, sourceFiber, thrownValue);\n        nextUnitOfWork = completeUnitOfWork(sourceFiber);\n      }\n      break;\n    } while (true);\n\n    // We're done performing work. Time to clean up.\n    var didCompleteRoot = false;\n    isWorking = false;\n\n    // Yield back to main thread.\n    if (didFatal) {\n      stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n      interruptedBy = null;\n      // There was a fatal error.\n      {\n        stack.resetStackAfterFatalErrorInDev();\n      }\n      return null;\n    } else if (nextUnitOfWork === null) {\n      // We reached the root.\n      if (isRootReadyForCommit) {\n        didCompleteRoot = true;\n        stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n        interruptedBy = null;\n        // The root successfully completed. It's ready for commit.\n        root.pendingCommitExpirationTime = expirationTime;\n        var finishedWork = root.current.alternate;\n        return finishedWork;\n      } else {\n        // The root did not complete.\n        stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n        interruptedBy = null;\n        invariant(\n          false,\n          \"Expired work should have completed. This error is likely caused \" +\n            \"by a bug in React. Please file an issue.\"\n        );\n      }\n    } else {\n      stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n      interruptedBy = null;\n      // There's more work to do, but we ran out of time. Yield back to\n      // the renderer.\n      return null;\n    }\n  }\n\n  function scheduleCapture(sourceFiber, boundaryFiber, value, expirationTime) {\n    // TODO: We only support dispatching errors.\n    var capturedValue = createCapturedValue(value, sourceFiber);\n    var update = {\n      expirationTime: expirationTime,\n      partialState: null,\n      callback: null,\n      isReplace: false,\n      isForced: false,\n      capturedValue: capturedValue,\n      next: null\n    };\n    insertUpdateIntoFiber(boundaryFiber, update);\n    scheduleWork(boundaryFiber, expirationTime);\n  }\n\n  function dispatch(sourceFiber, value, expirationTime) {\n    invariant(\n      !isWorking || isCommitting,\n      \"dispatch: Cannot dispatch during the render phase.\"\n    );\n\n    // TODO: Handle arrays\n\n    var fiber = sourceFiber[\"return\"];\n    while (fiber !== null) {\n      switch (fiber.tag) {\n        case ClassComponent:\n          var ctor = fiber.type;\n          var instance = fiber.stateNode;\n          if (\n            typeof ctor.getDerivedStateFromCatch === \"function\" ||\n            (typeof instance.componentDidCatch === \"function\" &&\n              !isAlreadyFailedLegacyErrorBoundary(instance))\n          ) {\n            scheduleCapture(sourceFiber, fiber, value, expirationTime);\n            return;\n          }\n          break;\n        // TODO: Handle async boundaries\n        case HostRoot:\n          scheduleCapture(sourceFiber, fiber, value, expirationTime);\n          return;\n      }\n      fiber = fiber[\"return\"];\n    }\n\n    if (sourceFiber.tag === HostRoot) {\n      // Error was thrown at the root. There is no parent, so the root\n      // itself should capture it.\n      scheduleCapture(sourceFiber, sourceFiber, value, expirationTime);\n    }\n  }\n\n  function onCommitPhaseError(fiber, error) {\n    return dispatch(fiber, error, Sync);\n  }\n\n  function computeAsyncExpiration(currentTime) {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var expirationMs = 5000;\n    var bucketSizeMs = 250;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  function computeInteractiveExpiration(currentTime) {\n    // Should complete within ~500ms. 600ms max.\n    var expirationMs = 500;\n    var bucketSizeMs = 100;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  // Creates a unique async expiration time.\n  function computeUniqueAsyncExpiration() {\n    var currentTime = recalculateCurrentTime();\n    var result = computeAsyncExpiration(currentTime);\n    if (result <= lastUniqueAsyncExpiration) {\n      // Since we assume the current time monotonically increases, we only hit\n      // this branch when computeUniqueAsyncExpiration is fired multiple times\n      // within a 200ms window (or whatever the async bucket size is).\n      result = lastUniqueAsyncExpiration + 1;\n    }\n    lastUniqueAsyncExpiration = result;\n    return lastUniqueAsyncExpiration;\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (fiber.mode & AsyncMode) {\n        if (isBatchingInteractiveUpdates) {\n          // This is an interactive update\n          var currentTime = recalculateCurrentTime();\n          expirationTime = computeInteractiveExpiration(currentTime);\n        } else {\n          // This is an async update\n          var _currentTime = recalculateCurrentTime();\n          expirationTime = computeAsyncExpiration(_currentTime);\n        }\n      } else {\n        // This is a sync update\n        expirationTime = Sync;\n      }\n    }\n    if (isBatchingInteractiveUpdates) {\n      // This is an interactive update. Keep track of the lowest pending\n      // interactive expiration time. This allows us to synchronously flush\n      // all interactive updates when needed.\n      if (\n        lowestPendingInteractiveExpirationTime === NoWork ||\n        expirationTime > lowestPendingInteractiveExpirationTime\n      ) {\n        lowestPendingInteractiveExpirationTime = expirationTime;\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (\n        node.expirationTime === NoWork ||\n        node.expirationTime > expirationTime\n      ) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (\n          node.alternate.expirationTime === NoWork ||\n          node.alternate.expirationTime > expirationTime\n        ) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node[\"return\"] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n          if (\n            !isWorking &&\n            nextRenderExpirationTime !== NoWork &&\n            expirationTime < nextRenderExpirationTime\n          ) {\n            // This is an interruption. (Used for performance tracking.)\n            interruptedBy = fiber;\n            resetStack();\n          }\n          if (\n            // If we're in the render phase, we don't need to schedule this root\n            // for an update, because we'll do it before we exit...\n            !isWorking ||\n            isCommitting ||\n            // ...unless this is a different root than the one we're rendering.\n            nextRoot !== root\n          ) {\n            // Add this root to the root schedule.\n            requestWork(root, expirationTime);\n          }\n          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n            invariant(\n              false,\n              \"Maximum update depth exceeded. This can happen when a \" +\n                \"component repeatedly calls setState inside \" +\n                \"componentWillUpdate or componentDidUpdate. React limits \" +\n                \"the number of nested updates to prevent infinite loops.\"\n            );\n          }\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node[\"return\"];\n    }\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    mostRecentCurrentTimeMs = now() - originalStartTimeMs;\n    mostRecentCurrentTime = msToExpirationTime(mostRecentCurrentTimeMs);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    var currentTime = recalculateCurrentTime();\n    expirationContext = computeAsyncExpiration(currentTime);\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n  function syncUpdates(fn, a, b, c, d) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn(a, b, c, d);\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var callbackExpirationTime = NoWork;\n  var callbackID = -1;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var lowestPendingInteractiveExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n  var isBatchingInteractiveUpdates = false;\n\n  var completedBatches = null;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  function scheduleCallbackWithExpiration(expirationTime) {\n    if (callbackExpirationTime !== NoWork) {\n      // A callback is already scheduled. Check its expiration time (timeout).\n      if (expirationTime > callbackExpirationTime) {\n        // Existing callback has sufficient timeout. Exit.\n        return;\n      } else {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n      // The request callback timer is already running. Don't start a new one.\n    } else {\n      startRequestCallbackTimer();\n    }\n\n    // Compute a timeout for the given expiration time.\n    var currentMs = now() - originalStartTimeMs;\n    var expirationMs = expirationTimeToMs(expirationTime);\n    var timeout = expirationMs - currentMs;\n\n    callbackExpirationTime = expirationTime;\n    callbackID = scheduleDeferredCallback(performAsyncWork, {\n      timeout: timeout\n    });\n  }\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    addRootToSchedule(root, expirationTime);\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(root, Sync, false);\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performSyncWork();\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n  function addRootToSchedule(root, expirationTime) {\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (\n        remainingExpirationTime === NoWork ||\n        expirationTime < remainingExpirationTime\n      ) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          invariant(\n            previousScheduledRoot !== null && lastScheduledRoot !== null,\n            \"Should have a previous and last root. This error is likely \" +\n              \"caused by a bug in React. Please file an issue.\"\n          );\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (\n            highestPriorityWork === NoWork ||\n            remainingExpirationTime < highestPriorityWork\n          ) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (\n      previousFlushedRoot !== null &&\n      previousFlushedRoot === highestPriorityRoot &&\n      highestPriorityWork === Sync\n    ) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, true, dl);\n  }\n\n  function performSyncWork() {\n    performWork(Sync, false, null);\n  }\n\n  function performWork(minExpirationTime, isAsync, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI && deadline !== null) {\n      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n      var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n      stopRequestCallbackTimer(didExpire, timeout);\n    }\n\n    if (isAsync) {\n      while (\n        nextFlushedRoot !== null &&\n        nextFlushedExpirationTime !== NoWork &&\n        (minExpirationTime === NoWork ||\n          minExpirationTime >= nextFlushedExpirationTime) &&\n        (!deadlineDidExpire ||\n          recalculateCurrentTime() >= nextFlushedExpirationTime)\n      ) {\n        performWorkOnRoot(\n          nextFlushedRoot,\n          nextFlushedExpirationTime,\n          !deadlineDidExpire\n        );\n        findHighestPriorityRoot();\n      }\n    } else {\n      while (\n        nextFlushedRoot !== null &&\n        nextFlushedExpirationTime !== NoWork &&\n        (minExpirationTime === NoWork ||\n          minExpirationTime >= nextFlushedExpirationTime)\n      ) {\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);\n        findHighestPriorityRoot();\n      }\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      callbackExpirationTime = NoWork;\n      callbackID = -1;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n\n    finishRendering();\n  }\n\n  function flushRoot(root, expirationTime) {\n    invariant(\n      !isRendering,\n      \"work.commit(): Cannot commit while already rendering. This likely \" +\n        \"means you attempted to commit from inside a lifecycle method.\"\n    );\n    // Perform work on root as if the given expiration time is the current time.\n    // This has the effect of synchronously flushing all work up to and\n    // including the given time.\n    nextFlushedRoot = root;\n    nextFlushedExpirationTime = expirationTime;\n    performWorkOnRoot(root, expirationTime, false);\n    // Flush any sync work that was scheduled by lifecycles\n    performSyncWork();\n    finishRendering();\n  }\n\n  function finishRendering() {\n    nestedUpdateCount = 0;\n\n    if (completedBatches !== null) {\n      var batches = completedBatches;\n      completedBatches = null;\n      for (var i = 0; i < batches.length; i++) {\n        var batch = batches[i];\n        try {\n          batch._onComplete();\n        } catch (error) {\n          if (!hasUnhandledError) {\n            hasUnhandledError = true;\n            unhandledError = error;\n          }\n        }\n      }\n    }\n\n    if (hasUnhandledError) {\n      var error = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw error;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime, isAsync) {\n    invariant(\n      !isRendering,\n      \"performWorkOnRoot was called recursively. This error is likely caused \" +\n        \"by a bug in React. Please file an issue.\"\n    );\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    if (!isAsync) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime, false);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          completeRoot(root, finishedWork, expirationTime);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, _finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime, true);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            completeRoot(root, _finishedWork, expirationTime);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  function completeRoot(root, finishedWork, expirationTime) {\n    // Check if there's a batch that matches this expiration time.\n    var firstBatch = root.firstBatch;\n    if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n      if (completedBatches === null) {\n        completedBatches = [firstBatch];\n      } else {\n        completedBatches.push(firstBatch);\n      }\n      if (firstBatch._defer) {\n        // This root is blocked from committing by a batch. Unschedule it until\n        // we receive another update.\n        root.finishedWork = finishedWork;\n        root.remainingExpirationTime = NoWork;\n        return;\n      }\n    }\n\n    // Commit the root.\n    root.finishedWork = null;\n    root.remainingExpirationTime = commitRoot(finishedWork);\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      // Disregard deadline.didTimeout. Only expired work should be flushed\n      // during a timeout. This path is only hit for non-expired work.\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  function onUncaughtError(error) {\n    invariant(\n      nextFlushedRoot !== null,\n      \"Should be working on a root. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performSyncWork();\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn, a) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn(a);\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn(a);\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn, a) {\n    invariant(\n      !isRendering,\n      \"flushSync was called from inside a lifecycle method. It cannot be \" +\n        \"called when React is already rendering.\"\n    );\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn, a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      performSyncWork();\n    }\n  }\n\n  function interactiveUpdates(fn, a, b) {\n    if (isBatchingInteractiveUpdates) {\n      return fn(a, b);\n    }\n    // If there are any pending interactive updates, synchronously flush them.\n    // This needs to happen before we read any handlers, because the effect of\n    // the previous event may influence which handlers are called during\n    // this event.\n    if (\n      !isBatchingUpdates &&\n      !isRendering &&\n      lowestPendingInteractiveExpirationTime !== NoWork\n    ) {\n      // Synchronously flush pending interactive updates.\n      performWork(lowestPendingInteractiveExpirationTime, false, null);\n      lowestPendingInteractiveExpirationTime = NoWork;\n    }\n    var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingInteractiveUpdates = true;\n    isBatchingUpdates = true;\n    try {\n      return fn(a, b);\n    } finally {\n      isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performSyncWork();\n      }\n    }\n  }\n\n  function flushInteractiveUpdates() {\n    if (!isRendering && lowestPendingInteractiveExpirationTime !== NoWork) {\n      // Synchronously flush pending interactive updates.\n      performWork(lowestPendingInteractiveExpirationTime, false, null);\n      lowestPendingInteractiveExpirationTime = NoWork;\n    }\n  }\n\n  function flushControlled(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, false, null);\n      }\n    }\n  }\n\n  return {\n    recalculateCurrentTime: recalculateCurrentTime,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    requestWork: requestWork,\n    flushRoot: flushRoot,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    flushControlled: flushControlled,\n    deferredUpdates: deferredUpdates,\n    syncUpdates: syncUpdates,\n    interactiveUpdates: interactiveUpdates,\n    flushInteractiveUpdates: flushInteractiveUpdates,\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n    legacyContext: legacyContext\n  };\n};\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\nvar ReactFiberReconciler$1 = function(config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n    computeUniqueAsyncExpiration =\n      _ReactFiberScheduler.computeUniqueAsyncExpiration,\n    recalculateCurrentTime = _ReactFiberScheduler.recalculateCurrentTime,\n    computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n    scheduleWork = _ReactFiberScheduler.scheduleWork,\n    requestWork = _ReactFiberScheduler.requestWork,\n    flushRoot = _ReactFiberScheduler.flushRoot,\n    batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n    unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n    flushSync = _ReactFiberScheduler.flushSync,\n    flushControlled = _ReactFiberScheduler.flushControlled,\n    deferredUpdates = _ReactFiberScheduler.deferredUpdates,\n    syncUpdates = _ReactFiberScheduler.syncUpdates,\n    interactiveUpdates = _ReactFiberScheduler.interactiveUpdates,\n    flushInteractiveUpdates = _ReactFiberScheduler.flushInteractiveUpdates,\n    legacyContext = _ReactFiberScheduler.legacyContext;\n\n  var findCurrentUnmaskedContext = legacyContext.findCurrentUnmaskedContext,\n    isContextProvider = legacyContext.isContextProvider,\n    processChildContext = legacyContext.processChildContext;\n\n  function getContextForSubtree(parentComponent) {\n    if (!parentComponent) {\n      return emptyObject;\n    }\n\n    var fiber = get(parentComponent);\n    var parentContext = findCurrentUnmaskedContext(fiber);\n    return isContextProvider(fiber)\n      ? processChildContext(fiber, parentContext)\n      : parentContext;\n  }\n\n  function scheduleRootUpdate(\n    current,\n    element,\n    currentTime,\n    expirationTime,\n    callback\n  ) {\n    {\n      if (\n        ReactDebugCurrentFiber.phase === \"render\" &&\n        ReactDebugCurrentFiber.current !== null &&\n        !didWarnAboutNestedUpdates\n      ) {\n        didWarnAboutNestedUpdates = true;\n        warning(\n          false,\n          \"Render methods should be a pure function of props and state; \" +\n            \"triggering nested component updates from render is not allowed. \" +\n            \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" +\n            \"Check the render method of %s.\",\n          getComponentName(ReactDebugCurrentFiber.current) || \"Unknown\"\n        );\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      !(callback === null || typeof callback === \"function\")\n        ? warning(\n            false,\n            \"render(...): Expected the last optional `callback` argument to be a \" +\n              \"function. Instead received: %s.\",\n            callback\n          )\n        : void 0;\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      capturedValue: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n\n    return expirationTime;\n  }\n\n  function updateContainerAtExpirationTime(\n    element,\n    container,\n    parentComponent,\n    currentTime,\n    expirationTime,\n    callback\n  ) {\n    // TODO: If this is a nested container, this won't be the root.\n    var current = container.current;\n\n    {\n      if (ReactFiberInstrumentation_1.debugTool) {\n        if (current.alternate === null) {\n          ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n        } else if (element === null) {\n          ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n        } else {\n          ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n        }\n      }\n    }\n\n    var context = getContextForSubtree(parentComponent);\n    if (container.context === null) {\n      container.context = context;\n    } else {\n      container.pendingContext = context;\n    }\n\n    return scheduleRootUpdate(\n      current,\n      element,\n      currentTime,\n      expirationTime,\n      callback\n    );\n  }\n\n  function findHostInstance(fiber) {\n    var hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    return hostFiber.stateNode;\n  }\n\n  return {\n    createContainer: function(containerInfo, isAsync, hydrate) {\n      return createFiberRoot(containerInfo, isAsync, hydrate);\n    },\n    updateContainer: function(element, container, parentComponent, callback) {\n      var current = container.current;\n      var currentTime = recalculateCurrentTime();\n      var expirationTime = computeExpirationForFiber(current);\n      return updateContainerAtExpirationTime(\n        element,\n        container,\n        parentComponent,\n        currentTime,\n        expirationTime,\n        callback\n      );\n    },\n    updateContainerAtExpirationTime: function(\n      element,\n      container,\n      parentComponent,\n      expirationTime,\n      callback\n    ) {\n      var currentTime = recalculateCurrentTime();\n      return updateContainerAtExpirationTime(\n        element,\n        container,\n        parentComponent,\n        currentTime,\n        expirationTime,\n        callback\n      );\n    },\n\n    flushRoot: flushRoot,\n\n    requestWork: requestWork,\n\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    syncUpdates: syncUpdates,\n\n    interactiveUpdates: interactiveUpdates,\n\n    flushInteractiveUpdates: flushInteractiveUpdates,\n\n    flushControlled: flushControlled,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function(container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n\n    findHostInstance: findHostInstance,\n\n    findHostInstanceWithNoPortals: function(fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    injectIntoDevTools: function(devToolsConfig) {\n      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n      return injectInternals(\n        Object.assign({}, devToolsConfig, {\n          findHostInstanceByFiber: function(fiber) {\n            return findHostInstance(fiber);\n          },\n          findFiberByHostInstance: function(instance) {\n            if (!findFiberByHostInstance) {\n              // Might not be implemented by the renderer.\n              return null;\n            }\n            return findFiberByHostInstance(instance);\n          }\n        })\n      );\n    }\n  };\n};\n\nvar ReactFiberReconciler$2 = Object.freeze({\n  default: ReactFiberReconciler$1\n});\n\nvar ReactFiberReconciler$3 =\n  (ReactFiberReconciler$2 && ReactFiberReconciler$1) || ReactFiberReconciler$2;\n\n// TODO: bundle Flow types with the package.\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$3[\"default\"]\n  ? ReactFiberReconciler$3[\"default\"]\n  : ReactFiberReconciler$3;\n\nvar viewConfigCallbacks = new Map();\nvar viewConfigs = new Map();\n\n/**\n * Registers a native view/component by name.\n * A callback is provided to load the view config from UIManager.\n * The callback is deferred until the view is actually rendered.\n * This is done to avoid causing Prepack deopts.\n */\nfunction register(name, callback) {\n  invariant(\n    !viewConfigCallbacks.has(name),\n    \"Tried to register two views with the same name %s\",\n    name\n  );\n  viewConfigCallbacks.set(name, callback);\n  return name;\n}\n\n/**\n * Retrieves a config for the specified view.\n * If this is the first time the view has been used,\n * This configuration will be lazy-loaded from UIManager.\n */\nfunction get$1(name) {\n  var viewConfig = void 0;\n  if (!viewConfigs.has(name)) {\n    var callback = viewConfigCallbacks.get(name);\n    invariant(\n      typeof callback === \"function\",\n      \"View config not found for name %s\",\n      name\n    );\n    viewConfigCallbacks.set(name, null);\n    viewConfig = callback();\n    viewConfigs.set(name, viewConfig);\n  } else {\n    viewConfig = viewConfigs.get(name);\n  }\n  invariant(viewConfig, \"View config not found for name %s\", name);\n  return viewConfig;\n}\n\nfunction _classCallCheck$2(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n// Modules provided by RN:\n/**\n * This component defines the same methods as NativeMethodsMixin but without the\n * findNodeHandle wrapper. This wrapper is unnecessary for HostComponent views\n * and would also result in a circular require.js dependency (since\n * ReactNativeFiber depends on this component and NativeMethodsMixin depends on\n * ReactNativeFiber).\n */\n\nvar ReactNativeFiberHostComponent = (function() {\n  function ReactNativeFiberHostComponent(tag, viewConfig) {\n    _classCallCheck$2(this, ReactNativeFiberHostComponent);\n\n    this._nativeTag = tag;\n    this._children = [];\n    this.viewConfig = viewConfig;\n  }\n\n  ReactNativeFiberHostComponent.prototype.blur = function blur() {\n    TextInputState.blurTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.focus = function focus() {\n    TextInputState.focusTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {\n    UIManager.measure(this._nativeTag, mountSafeCallback(this, callback));\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(\n    callback\n  ) {\n    UIManager.measureInWindow(\n      this._nativeTag,\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      this._nativeTag,\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(\n    nativeProps\n  ) {\n    {\n      warnForStyleProps(nativeProps, this.viewConfig.validAttributes);\n    }\n\n    var updatePayload = create(nativeProps, this.viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        this._nativeTag,\n        this.viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  };\n\n  return ReactNativeFiberHostComponent;\n})();\n\nvar hasNativePerformanceNow =\n  typeof performance === \"object\" && typeof performance.now === \"function\";\n\nvar now = hasNativePerformanceNow\n  ? function() {\n      return performance.now();\n    }\n  : function() {\n      return Date.now();\n    };\n\nvar scheduledCallback = null;\nvar frameDeadline = 0;\n\nvar frameDeadlineObject = {\n  timeRemaining: function() {\n    return frameDeadline - now();\n  },\n  didTimeout: false\n};\n\nfunction setTimeoutCallback() {\n  // TODO (bvaughn) Hard-coded 5ms unblocks initial async testing.\n  // React API probably changing to boolean rather than time remaining.\n  // Longer-term plan is to rewrite this using shared memory,\n  // And just return the value of the bit as the boolean.\n  frameDeadline = now() + 5;\n\n  var callback = scheduledCallback;\n  scheduledCallback = null;\n  if (callback !== null) {\n    callback(frameDeadlineObject);\n  }\n}\n\n// RN has a poor polyfill for requestIdleCallback so we aren't using it.\n// This implementation is only intended for short-term use anyway.\n// We also don't implement cancel functionality b'c Fiber doesn't currently need it.\nfunction scheduleDeferredCallback(callback) {\n  // We assume only one callback is scheduled at a time b'c that's how Fiber works.\n  scheduledCallback = callback;\n  return setTimeout(setTimeoutCallback, 1);\n}\n\nfunction cancelDeferredCallback(callbackID) {\n  scheduledCallback = null;\n  clearTimeout(callbackID);\n}\n\n// Modules provided by RN:\nfunction recursivelyUncacheFiberNode(node) {\n  if (typeof node === \"number\") {\n    // Leaf node (eg text)\n    uncacheFiberNode(node);\n  } else {\n    uncacheFiberNode(node._nativeTag);\n\n    node._children.forEach(recursivelyUncacheFiberNode);\n  }\n}\n\nvar NativeRenderer = reactReconciler({\n  appendInitialChild: function(parentInstance, child) {\n    parentInstance._children.push(child);\n  },\n  createInstance: function(\n    type,\n    props,\n    rootContainerInstance,\n    hostContext,\n    internalInstanceHandle\n  ) {\n    var tag = ReactNativeTagHandles.allocateTag();\n    var viewConfig = get$1(type);\n\n    {\n      for (var key in viewConfig.validAttributes) {\n        if (props.hasOwnProperty(key)) {\n          deepFreezeAndThrowOnMutationInDev(props[key]);\n        }\n      }\n    }\n\n    var updatePayload = create(props, viewConfig.validAttributes);\n\n    UIManager.createView(\n      tag, // reactTag\n      viewConfig.uiViewClassName, // viewName\n      rootContainerInstance, // rootTag\n      updatePayload\n    );\n\n    var component = new ReactNativeFiberHostComponent(tag, viewConfig);\n\n    precacheFiberNode(internalInstanceHandle, tag);\n    updateFiberProps(tag, props);\n\n    // Not sure how to avoid this cast. Flow is okay if the component is defined\n    // in the same file but if it's external it can't see the types.\n    return component;\n  },\n  createTextInstance: function(\n    text,\n    rootContainerInstance,\n    hostContext,\n    internalInstanceHandle\n  ) {\n    var tag = ReactNativeTagHandles.allocateTag();\n\n    UIManager.createView(\n      tag, // reactTag\n      \"RCTRawText\", // viewName\n      rootContainerInstance, // rootTag\n      { text: text }\n    );\n\n    precacheFiberNode(internalInstanceHandle, tag);\n\n    return tag;\n  },\n  finalizeInitialChildren: function(\n    parentInstance,\n    type,\n    props,\n    rootContainerInstance\n  ) {\n    // Don't send a no-op message over the bridge.\n    if (parentInstance._children.length === 0) {\n      return false;\n    }\n\n    // Map from child objects to native tags.\n    // Either way we need to pass a copy of the Array to prevent it from being frozen.\n    var nativeTags = parentInstance._children.map(function(child) {\n      return typeof child === \"number\"\n        ? child // Leaf node (eg text)\n        : child._nativeTag;\n    });\n\n    UIManager.setChildren(\n      parentInstance._nativeTag, // containerTag\n      nativeTags\n    );\n\n    return false;\n  },\n  getRootHostContext: function() {\n    return emptyObject;\n  },\n  getChildHostContext: function() {\n    return emptyObject;\n  },\n  getPublicInstance: function(instance) {\n    return instance;\n  },\n\n  now: now,\n\n  prepareForCommit: function() {\n    // Noop\n  },\n  prepareUpdate: function(\n    instance,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n    hostContext\n  ) {\n    return emptyObject;\n  },\n  resetAfterCommit: function() {\n    // Noop\n  },\n\n  scheduleDeferredCallback: scheduleDeferredCallback,\n  cancelDeferredCallback: cancelDeferredCallback,\n\n  shouldDeprioritizeSubtree: function(type, props) {\n    return false;\n  },\n  shouldSetTextContent: function(type, props) {\n    // TODO (bvaughn) Revisit this decision.\n    // Always returning false simplifies the createInstance() implementation,\n    // But creates an additional child Fiber for raw text children.\n    // No additional native views are created though.\n    // It's not clear to me which is better so I'm deferring for now.\n    // More context @ github.com/facebook/react/pull/8560#discussion_r92111303\n    return false;\n  },\n\n  mutation: {\n    appendChild: function(parentInstance, child) {\n      var childTag = typeof child === \"number\" ? child : child._nativeTag;\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      if (index >= 0) {\n        children.splice(index, 1);\n        children.push(child);\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerTag\n          [index], // moveFromIndices\n          [children.length - 1], // moveToIndices\n          [], // addChildReactTags\n          [], // addAtIndices\n          []\n        );\n      } else {\n        children.push(child);\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerTag\n          [], // moveFromIndices\n          [], // moveToIndices\n          [childTag], // addChildReactTags\n          [children.length - 1], // addAtIndices\n          []\n        );\n      }\n    },\n    appendChildToContainer: function(parentInstance, child) {\n      var childTag = typeof child === \"number\" ? child : child._nativeTag;\n      UIManager.setChildren(\n        parentInstance, // containerTag\n        [childTag]\n      );\n    },\n    commitTextUpdate: function(textInstance, oldText, newText) {\n      UIManager.updateView(\n        textInstance, // reactTag\n        \"RCTRawText\", // viewName\n        { text: newText }\n      );\n    },\n    commitMount: function(instance, type, newProps, internalInstanceHandle) {\n      // Noop\n    },\n    commitUpdate: function(\n      instance,\n      updatePayloadTODO,\n      type,\n      oldProps,\n      newProps,\n      internalInstanceHandle\n    ) {\n      var viewConfig = instance.viewConfig;\n\n      updateFiberProps(instance._nativeTag, newProps);\n\n      var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);\n\n      // Avoid the overhead of bridge calls if there's no update.\n      // This is an expensive no-op for Android, and causes an unnecessary\n      // view invalidation for certain components (eg RCTTextInput) on iOS.\n      if (updatePayload != null) {\n        UIManager.updateView(\n          instance._nativeTag, // reactTag\n          viewConfig.uiViewClassName, // viewName\n          updatePayload\n        );\n      }\n    },\n    insertBefore: function(parentInstance, child, beforeChild) {\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      // Move existing child or add new child?\n      if (index >= 0) {\n        children.splice(index, 1);\n        var beforeChildIndex = children.indexOf(beforeChild);\n        children.splice(beforeChildIndex, 0, child);\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerID\n          [index], // moveFromIndices\n          [beforeChildIndex], // moveToIndices\n          [], // addChildReactTags\n          [], // addAtIndices\n          []\n        );\n      } else {\n        var _beforeChildIndex = children.indexOf(beforeChild);\n        children.splice(_beforeChildIndex, 0, child);\n\n        var childTag = typeof child === \"number\" ? child : child._nativeTag;\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerID\n          [], // moveFromIndices\n          [], // moveToIndices\n          [childTag], // addChildReactTags\n          [_beforeChildIndex], // addAtIndices\n          []\n        );\n      }\n    },\n    insertInContainerBefore: function(parentInstance, child, beforeChild) {\n      // TODO (bvaughn): Remove this check when...\n      // We create a wrapper object for the container in ReactNative render()\n      // Or we refactor to remove wrapper objects entirely.\n      // For more info on pros/cons see PR #8560 description.\n      invariant(\n        typeof parentInstance !== \"number\",\n        \"Container does not support insertBefore operation\"\n      );\n    },\n    removeChild: function(parentInstance, child) {\n      recursivelyUncacheFiberNode(child);\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      children.splice(index, 1);\n\n      UIManager.manageChildren(\n        parentInstance._nativeTag, // containerID\n        [], // moveFromIndices\n        [], // moveToIndices\n        [], // addChildReactTags\n        [], // addAtIndices\n        [index]\n      );\n    },\n    removeChildFromContainer: function(parentInstance, child) {\n      recursivelyUncacheFiberNode(child);\n      UIManager.manageChildren(\n        parentInstance, // containerID\n        [], // moveFromIndices\n        [], // moveToIndices\n        [], // addChildReactTags\n        [], // addAtIndices\n        [0]\n      );\n    },\n    resetTextContent: function(instance) {\n      // Noop\n    }\n  }\n});\n\n// Module provided by RN:\nvar getInspectorDataForViewTag = void 0;\n\n{\n  var traverseOwnerTreeUp = function(hierarchy, instance) {\n    if (instance) {\n      hierarchy.unshift(instance);\n      traverseOwnerTreeUp(hierarchy, instance._debugOwner);\n    }\n  };\n\n  var getOwnerHierarchy = function(instance) {\n    var hierarchy = [];\n    traverseOwnerTreeUp(hierarchy, instance);\n    return hierarchy;\n  };\n\n  var lastNonHostInstance = function(hierarchy) {\n    for (var i = hierarchy.length - 1; i > 1; i--) {\n      var instance = hierarchy[i];\n\n      if (instance.tag !== HostComponent) {\n        return instance;\n      }\n    }\n    return hierarchy[0];\n  };\n\n  var getHostProps = function(fiber) {\n    var host = findCurrentHostFiber(fiber);\n    if (host) {\n      return host.memoizedProps || emptyObject;\n    }\n    return emptyObject;\n  };\n\n  var getHostNode = function(fiber, findNodeHandle) {\n    var hostNode = void 0;\n    // look for children first for the hostNode\n    // as composite fibers do not have a hostNode\n    while (fiber) {\n      if (fiber.stateNode !== null && fiber.tag === HostComponent) {\n        hostNode = findNodeHandle(fiber.stateNode);\n      }\n      if (hostNode) {\n        return hostNode;\n      }\n      fiber = fiber.child;\n    }\n    return null;\n  };\n\n  var createHierarchy = function(fiberHierarchy) {\n    return fiberHierarchy.map(function(fiber) {\n      return {\n        name: getComponentName(fiber),\n        getInspectorData: function(findNodeHandle) {\n          return {\n            measure: function(callback) {\n              return UIManager.measure(\n                getHostNode(fiber, findNodeHandle),\n                callback\n              );\n            },\n            props: getHostProps(fiber),\n            source: fiber._debugSource\n          };\n        }\n      };\n    });\n  };\n\n  getInspectorDataForViewTag = function(viewTag) {\n    var closestInstance = getInstanceFromTag(viewTag);\n\n    // Handle case where user clicks outside of ReactNative\n    if (!closestInstance) {\n      return {\n        hierarchy: [],\n        props: emptyObject,\n        selection: null,\n        source: null\n      };\n    }\n\n    var fiber = findCurrentFiberUsingSlowPath(closestInstance);\n    var fiberHierarchy = getOwnerHierarchy(fiber);\n    var instance = lastNonHostInstance(fiberHierarchy);\n    var hierarchy = createHierarchy(fiberHierarchy);\n    var props = getHostProps(instance);\n    var source = instance._debugSource;\n    var selection = fiberHierarchy.indexOf(instance);\n\n    return {\n      hierarchy: hierarchy,\n      props: props,\n      selection: selection,\n      source: source\n    };\n  };\n}\n\n/**\n * Creates a renderable ReactNative host component.\n * Use this method for view configs that are loaded from UIManager.\n * Use createReactNativeComponentClass() for view configs defined within JavaScript.\n *\n * @param {string} config iOS View configuration.\n * @private\n */\nvar createReactNativeComponentClass = function(name, callback) {\n  return register(name, callback);\n};\n\n// Module provided by RN:\n/**\n * Capture an image of the screen, window or an individual view. The image\n * will be stored in a temporary file that will only exist for as long as the\n * app is running.\n *\n * The `view` argument can be the literal string `window` if you want to\n * capture the entire window, or it can be a reference to a specific\n * React Native component.\n *\n * The `options` argument may include:\n * - width/height (number) - the width and height of the image to capture.\n * - format (string) - either 'png' or 'jpeg'. Defaults to 'png'.\n * - quality (number) - the quality when using jpeg. 0.0 - 1.0 (default).\n *\n * Returns a Promise.\n * @platform ios\n */\nfunction takeSnapshot(view, options) {\n  if (typeof view !== \"number\" && view !== \"window\") {\n    view = findNumericNodeHandleFiber(view) || \"window\";\n  }\n\n  // Call the hidden '__takeSnapshot' method; the main one throws an error to\n  // prevent accidental backwards-incompatible usage.\n  return UIManager.__takeSnapshot(view, options);\n}\n\n// Module provided by RN:\ninjectFindHostInstance(NativeRenderer.findHostInstance);\n\ninjection$2.injectRenderer(NativeRenderer);\n\nvar roots = new Map();\n\nvar ReactNativeRenderer = {\n  NativeComponent: ReactNativeComponent,\n\n  findNodeHandle: findNumericNodeHandleFiber,\n\n  render: function(element, containerTag, callback) {\n    var root = roots.get(containerTag);\n\n    if (!root) {\n      // TODO (bvaughn): If we decide to keep the wrapper component,\n      // We could create a wrapper for containerTag as well to reduce special casing.\n      root = NativeRenderer.createContainer(containerTag, false, false);\n      roots.set(containerTag, root);\n    }\n    NativeRenderer.updateContainer(element, root, null, callback);\n\n    return NativeRenderer.getPublicRootInstance(root);\n  },\n  unmountComponentAtNode: function(containerTag) {\n    var root = roots.get(containerTag);\n    if (root) {\n      // TODO: Is it safe to reset this now or should I wait since this unmount could be deferred?\n      NativeRenderer.updateContainer(null, root, null, function() {\n        roots[\"delete\"](containerTag);\n      });\n    }\n  },\n  unmountComponentAtNodeAndRemoveContainer: function(containerTag) {\n    ReactNativeRenderer.unmountComponentAtNode(containerTag);\n\n    // Call back into native to remove all of the subviews from this container\n    UIManager.removeRootView(containerTag);\n  },\n  createPortal: function(children, containerTag) {\n    var key =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    return createPortal(children, containerTag, null, key);\n  },\n\n  unstable_batchedUpdates: batchedUpdates,\n\n  flushSync: NativeRenderer.flushSync,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // Used as a mixin in many createClass-based components\n    NativeMethodsMixin: NativeMethodsMixin,\n    // Used by react-native-github/Libraries/ components\n    ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin, // requireNativeComponent\n    ReactNativeComponentTree: ReactNativeComponentTree, // ScrollResponder\n    ReactNativePropRegistry: ReactNativePropRegistry, // flattenStyle, Stylesheet\n    TouchHistoryMath: TouchHistoryMath, // PanResponder\n    createReactNativeComponentClass: createReactNativeComponentClass, // RCTText, RCTView, ReactNativeART\n    takeSnapshot: takeSnapshot\n  }\n};\n\n{\n  // $FlowFixMe\n  Object.assign(\n    ReactNativeRenderer.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,\n    {\n      // TODO: none of these work since Fiber. Remove these dependencies.\n      // Used by RCTRenderingPerf, Systrace:\n      ReactDebugTool: {\n        addHook: function() {},\n        removeHook: function() {}\n      },\n      // Used by ReactPerfStallHandler, RCTRenderingPerf:\n      ReactPerf: {\n        start: function() {},\n        stop: function() {},\n        printInclusive: function() {},\n        printWasted: function() {}\n      }\n    }\n  );\n}\n\nNativeRenderer.injectIntoDevTools({\n  findFiberByHostInstance: getInstanceFromTag,\n  getInspectorDataForViewTag: getInspectorDataForViewTag,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: \"react-native-renderer\"\n});\n\nvar ReactNativeRenderer$2 = Object.freeze({\n  default: ReactNativeRenderer\n});\n\nvar ReactNativeRenderer$3 =\n  (ReactNativeRenderer$2 && ReactNativeRenderer) || ReactNativeRenderer$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactNativeRenderer = ReactNativeRenderer$3[\"default\"]\n  ? ReactNativeRenderer$3[\"default\"]\n  : ReactNativeRenderer$3;\n\nmodule.exports = reactNativeRenderer;\n\n  })();\n}\n"]}